[
  {
    "objectID": "Ch3_Symmetric_Encryption/3.19.html",
    "href": "Ch3_Symmetric_Encryption/3.19.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.19: RESISTANCE IS FUTILE\nFinish the code for the padding oracle attack. We‚Äôve given you the major pieces, but it will still take some work to put everything together. We will do a few things to try and simplify as much as possible. First, pick a message that is exactly a multiple of 16 bytes in length (the AES block size) and create a fixed padding to append. The fixed padding can be any \\(16\\) bytes as long as the last byte is \\(15\\) (that‚Äôs the whole point of the exercise, right?). Encrypt this message and pass it to the oracle to make sure that code is working.\nNext, test recovering the last byte of the first block of the message. In a loop, create a new key and IV pair (and a new oracle with these values), encrypt the message, and call the lucky_get_one_byte() function, setting block number to \\(0\\). Repeat the loop until this function succeeds and verify that the recovered byte is correct. Note that, in Python, an individual byte isn‚Äôt treated as a byte type but is converted to an integer.\nThe last step in order to decode the entire message is to be able to make any byte the last byte of a block. Again, for simplicity keep the message being encrypted a perfect multiple of \\(16\\). To push any byte to the end of a block, add some extra bytes at the beginning and cut off an equal number at the end. You can now recover the entire message one byte at a time!\n\n\n# ex3_19.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import padding\nimport os\n\ndef sslv3Pad(msg): \n    padNeeded = (16 - (len(msg) % 16)) - 1\n    padding = padNeeded.to_bytes(padNeeded+1, \"big\")\n    return msg + padding \n\ndef sslv3Unpad(padded_msg): \n    paddingLen = padded_msg[-1] + 1 \n    return padded_msg[:-paddingLen]\n\nclass Oracle:\n    '''\n    The Oracle class basically models the SSLv3 Servers. \n    '''\n    def __init__(self, key, iv):\n        self.key = key\n        self.iv = iv\n\n    def accept(self, ciphertext) -&gt; bool:\n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        decryptor = aesCipher.decryptor()\n        plaintext = decryptor.update(ciphertext)\n        plaintext += decryptor.finalize()\n        return plaintext[-1] == 15\n\n    def update_key_and_iv(self, ciphertext) -&gt; bytes: \n        '''\n        Change the key & iv that ciphertext was created. \n        '''\n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        decryptor = aesCipher.decryptor()\n        plaintext = decryptor.update(ciphertext)\n        plaintext += decryptor.finalize()\n\n        self.key = os.urandom(16)\n        self.iv = os.urandom(16)\n\n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        encryptor = aesCipher.encryptor() \n        ciphertext = encryptor.update(plaintext)\n        ciphertext += encryptor.finalize()\n        return ciphertext  \n\n\n    def right_shift_plaintext(self,ciphertext: bytes) -&gt; bytes: \n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        decryptor = aesCipher.decryptor()\n        plaintext = decryptor.update(ciphertext)\n        plaintext += decryptor.finalize()\n\n        plaintext = b\"-\" + plaintext[:-17] + plaintext[-16:]\n        \n        encryptor = aesCipher.encryptor() \n        _ciphertext = encryptor.update(plaintext) \n        _ciphertext += encryptor.finalize()\n        return _ciphertext \n    \n    @staticmethod\n    def start_experiment(): \n        msg = b\"msg is 16 bytesS\"\n        msg_padded = sslv3Pad(msg) \n\n        o = Oracle(key=os.urandom(16), iv=os.urandom(16))\n        aesCipher = Cipher(algorithms.AES(o.key),\n                           modes.CBC(o.iv),\n                           backend=default_backend())\n        encryptor = aesCipher.encryptor() \n        ciphertext = encryptor.update(msg_padded)\n        ciphertext += encryptor.finalize() \n        assert(o.accept(ciphertext=ciphertext))\n        return ciphertext, o \n        \n\n# This function assumes that the last cipher text block is a full\n# block of SSLV3 padding\ndef lucky_get_one_byte(iv, ciphertext, block_number, oracle):\n    block_start = block_number * 16\n    block_end = block_start + 16\n    block = ciphertext[block_start:block_end]\n\n    # Copy the block over the last block.\n    mod_ciphertext = ciphertext[:-16] + block\n    if not oracle.accept(mod_ciphertext):\n        return False, None\n\n    # This is valid! Let's get the byte!\n    # We first need the byte decrypted from the block.\n    # It was XORed with second to last block, so\n    # byte = 15 XOR (last byte of second-to-last block).\n    second_to_last = ciphertext[-32:-16]\n    intermediate = second_to_last[-1]^15\n\n    # We still have to XOR it with its *real*\n    # preceding block in order to get the true value.\n    if block_number == 0:\n        prev_block = iv\n    else:\n        prev_block = ciphertext[block_start-16:block_start]\n\n    return True, intermediate ^ prev_block[-1]\n    \nif __name__ == '__main__': \n    ciphertext, o = Oracle.start_experiment() \n    plaintext_recovered = []\n    # let's suppose the attacker knows that the plaintext is 16 characters/bytes long. \n    length_of_plaintext_length = 16 \n    while length_of_plaintext_length &gt; 0: \n        status, byte = lucky_get_one_byte(iv=o.iv, ciphertext=ciphertext, block_number=0, oracle=o) \n        if (status): \n            plaintext_recovered.append(byte)\n            ciphertext = o.right_shift_plaintext(ciphertext=ciphertext)\n            length_of_plaintext_length -= 1\n        else: \n            ciphertext = o.update_key_and_iv(ciphertext=ciphertext)\n        \n\n    plaintext_recovered.reverse()\n    print(\"Plaintext recovered: \", bytes(plaintext_recovered).decode())\nLooks like we can recover a whole AES block using this technique as follows:\n\nNote that the code that recovered the plaintext (i.e.¬†the last if condition in the script), accomplished it, without directly accessing o.key. It only used public methods of the Oracle."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.9.html",
    "href": "Ch3_Symmetric_Encryption/3.9.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.9: THE MASK OF XOR-0?\nAlthough this exercise will be even more important in counter mode, it‚Äôs useful to understand how XOR can be used to mask data. Create \\(16\\) bytes of plaintext (a \\(16\\)-character message) and \\(16\\) bytes of random data (e.g., using os.urandom(16)). XOR these two messages together. There‚Äôs no built-in operation for XORing a series of bytes, so you‚Äôll have to XOR each byte individually using, for example, a loop. When you are done, take a look at the output. How ‚Äúreadable‚Äù is it? Now, XOR this output with the same random bytes again. How does the output look like now?\n\n\n# ex3_9.py \n\ndef xor_two_byte_strings(x: bytes, y: bytes) -&gt; bytes: \n    assert(len(x) == len(y))\n    \n    result = []\n    for _1, _2 in zip(x, y): \n        result.append(_1 ^ _2)\n    return bytes(result)"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.3.html",
    "href": "Ch3_Symmetric_Encryption/3.3.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.3 HISTORY LESSON\nDo some research online about DES and 3DES. What is the block size of DES? What is its key size? How does 3DES strengthen DES?\n\n\nThe block size of DES is \\(64\\) bits.\nThe key size of DES is \\(56\\) bits.\n3DES strengthens DES by increasing its key size. When using Keying Option 1 (read more here) 3DES will have \\(3\\) independent keys each of size \\(56\\) bits. Thus the key size for 3DES is \\(3 \\times 56 = 168\\) bits. But it is still vulnerable to meet-in-the-middle attack, but the attack requires \\(2^{2 \\times 56}\\) steps."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.14.html",
    "href": "Ch3_Symmetric_Encryption/3.14.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.14: PARALLEL COUNTER MODE\nExtend your counter mode implementation to use a thread pool to generate the key stream in parallel. Remember that to generate a block of key stream, all that is required is the starting IV and which block of key stream is being generated (e.g., 0 for the first 16-byte block, 1 for the second 16-byte block, etc.). Start by creating a function that can generate any particular block of key stream, perhaps something like keystream(IV, i). Next, parallelize the generation of a key stream up to n by dividing the counter sequence among independent processes any way you please, and have them all work on generating their key stream blocks independently.\n\n\nThe following is a parallel version of the code in the previous question.\nI used concurrent.futures.ThreadPoolExecutor to parallelize.\n# ex3_14.py \n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os \nimport concurrent.futures\n\n\nAES_BLOCK_SIZE_IN_BYTES = 16\nAES_BLOCK_SIZE_IN_BITS = 128\nNUMBER_OF_KEYSTREAM_BLOCKS_TO_GENERATE_AT_ONCE = 30\nMAX_NUMBER_OF_WORKERS = 6\n\nclass MyOwnCTR:\n    def __init__(self, key: bytes, nonce: bytes): \n        assert(len(nonce) == AES_BLOCK_SIZE_IN_BYTES)\n        self.key = key \n        self.nonce = nonce \n\n    def encryptor(self): \n        return Encryptor(config=self) \n    \n    def decryptor(self): \n        # Note that in CTR, encryption and decryption are exactly the same operations. \n        return Encryptor(config=self)\n    \nclass Encryptor: \n    def __init__(self, config: MyOwnCTR):  \n        self.config = config \n        self.keystream = []\n        self.current_index = 0 \n        self.e_current_nonce = b\"\" \n        self.buffer = b\"\"\n\n        self._encryptor = Cipher(\n            algorithm=algorithms.AES(self.config.key), \n            mode=modes.ECB(), \n            backend=default_backend(),\n        ).encryptor()\n    \n    def advance(self): \n        if len(self.keystream) &gt; 0: \n            self.e_current_nonce = self.keystream[0] \n            del self.keystream[0] \n            return\n        \n        # since the keystream is empty, let's populate it. \n        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_NUMBER_OF_WORKERS) as executor: \n            future_to_index = dict()\n\n            for i in range(NUMBER_OF_KEYSTREAM_BLOCKS_TO_GENERATE_AT_ONCE): \n                fut = executor.submit(self.get_the_ith_keyblock, self.config.nonce, self.current_index)\n                future_to_index[fut] = i\n                self.current_index += 1 \n            \n            result_to_index = []\n\n            for future in concurrent.futures.as_completed(future_to_index): \n                i = future_to_index[future]\n                keyblock = future.result() \n                result_to_index.append((keyblock,i))\n            \n            result_to_index.sort(key=lambda x: x[1])\n            for t in result_to_index: \n                self.keystream.append(t[0])        \n\n        self.e_current_nonce = self.keystream[0] \n        del self.keystream[0] \n        return\n  \n    def update(self, plaintext: bytes) -&gt; bytes: \n        self.buffer += plaintext\n        retval = b\"\"  \n        while len(self.buffer) &gt; 0:\n            if len(self.e_current_nonce) == 0: \n                self.advance()\n            k = min(\n                len(self.buffer), \n                len(self.e_current_nonce),\n            )\n            retval += xor_two_byte_strings(\n                self.buffer[:k],\n                self.e_current_nonce[:k],\n            )\n            self.buffer = self.buffer[k:]\n            self.e_current_nonce = self.e_current_nonce[k:]\n        return retval\n    \n    def finalize(self): \n        assert(len(self.buffer) == 0)\n        return b\"\" \n\n    def get_the_ith_keyblock(self, nonce: bytes, i: int) -&gt; bytes: \n        # get the i th nonce\n        i_th_nonce = (int.from_bytes(nonce,'big') + i)%(2**128)\n        i_th_nonce = int.to_bytes(i_th_nonce, length=16, byteorder='big')\n        return self._encryptor.update(i_th_nonce)\n\n# the following function is taken from Exercise 3.9. \ndef xor_two_byte_strings(x: bytes, y: bytes) -&gt; bytes: \n    assert(len(x) == len(y))\n    \n    result = []\n    for _1, _2 in zip(x, y): \n        result.append(_1 ^ _2)\n    return bytes(result)\n\nif __name__ == '__main__': \n    key = os.urandom(32) \n    nonce = os.urandom(16) \n\n    plaintext = b\"This is a very secret and long plaintext...\"\n\n    my_ctr = MyOwnCTR(key=key, nonce=nonce) \n    my_ctr_encryptor = my_ctr.encryptor()\n    my_ctr_decryptor = my_ctr.decryptor()\n\n    ciphertext1 = my_ctr_encryptor.update(plaintext)\n    print(my_ctr_decryptor.update(ciphertext1))\n\n    official_ctr = Cipher(\n        algorithm=algorithms.AES(key), \n        mode=modes.CTR(nonce),\n        backend=default_backend(),\n    )\n    official_ctr_encryptor = official_ctr.encryptor()\n    official_ctr_decryptor = official_ctr.decryptor()\n\n    ciphertext2 = official_ctr_encryptor.update(plaintext) \n    print(official_ctr_decryptor.update(ciphertext2))\n\n    print(f\"Passed: {ciphertext1 == ciphertext2}\")\nRunning the above code gives the following result:"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.2.html",
    "href": "Ch3_Symmetric_Encryption/3.2.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.2 UPDATED TECHNOLOGY\nUpgrade the Caesar cipher application from Chapter 1 to use AES. Instead of specifying a shift value, figure out how to get keys in and out of the program. You will also have to deal with the 16-byte message size issue. Good luck!\n\n\nThe following program uses the PBKDF, scrypt with a fixed salt for generating the keys as input for the AES program. Thus the key can be any passphrase. Implementation is given in the kdf() function\nThe issue of padding has been solved by the two static functions inside of the class Padding.\n# ex3_2.py\n\n# Do NOT use ECB in production!!!\nfrom cryptography.hazmat.primitives.kdf.scrypt import Scrypt\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport base64\n\ndef kdf(passphrase: str) -&gt; bytes: \n    # In cryptography, a kdf (key derivation function) is a \n    # cryptographic algorithm that derives one or more secret keys\n    # from a secret value such as a passphrase.\n    # To read more: https://en.wikipedia.org/wiki/Key_derivation_function\n\n    # a fixed, randomly generated salt, using os.urandom\n    salt = b'x\"&\\xd9__7\\xac\\xc6\\xcd\\x06r\\xd6\\xe5\\xce\\x97'\n\n    _scrypt = Scrypt(salt=salt, length=16, n=2**14, r=8, p=1, backend=default_backend())\n    key = _scrypt.derive(passphrase.encode('utf-8'))\n    return key\n\nclass Padding:\n    @staticmethod    \n    def pad_it_up(msg: bytes) -&gt; bytes: \n        '''\n        This function is used to pad the message.\n\n        Technique: Determine the number of padding bytes required.\n        This is a number n which satisfies 1 &lt;= n &lt;= 16\n        and n + len(msg) is a multiple of 16. Pad the plaintext by appending\n        n bytes, each with value n. (Read more in Chapter 4 of the book  \n        \"Cryptography Engineering by Niels Ferguson, Bruce Schneier, Tadayoshi Kohno\".)\n        ''' \n        n = 16 - len(msg) % 16\n        return msg + bytes([n] * n)\n    \n    @staticmethod\n    def unpad_it_up(msg: bytes) -&gt; bytes: \n        '''this function is used to remove the pads from the message''' \n        n = msg[-1]\n        # then ignore the last n bytes\n        return msg[:-1*n]\n\ndef encrypt_using_aes_ecb(plaintext: str, key: bytes) -&gt; str: \n    proper_plaintext = Padding.pad_it_up(plaintext.encode('utf-8'))\n    aesCipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n    aesEncryptor = aesCipher.encryptor()\n    ciphertext = aesEncryptor.update(proper_plaintext)\n    return base64.b64encode(ciphertext).decode()\n\n\ndef decrypt_using_aes_ecb(ciphertext: str, key: bytes) -&gt; str: \n    proper_ciphertext = base64.b64decode(ciphertext.encode())\n    aesCipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n    aesDecryptor = aesCipher.decryptor()\n    plaintext = aesDecryptor.update(proper_ciphertext)\n    plaintext = Padding.unpad_it_up(plaintext)\n    return plaintext.decode()\n\nif __name__ == \"__main__\":\n    passphrase = \"very-bad-password\"\n    aes_key = kdf(passphrase=passphrase)\n    while True:\n        print(\"\\nAES ECB MODE\")\n        print(\"--------------------\")\n        print(\"\\tCurrent Passphrase: {}\\n\".format(passphrase))\n        print(\"\\t1. Encrypt Message.\")\n        print(\"\\t2. Decrypt Message.\")\n        print(\"\\t3. Change Passphrase.\")\n        print(\"\\t4. Quit.\\n\")\n        choice = input(\"&gt;&gt; \")\n        print()\n\n        if choice == '1':\n            message = input(\"\\nMessage to encrypt: \")\n            print(\"Encrypted Message: {}\".format(\n                encrypt_using_aes_ecb(message, aes_key)))\n\n        elif choice == '2':\n            message = input(\"\\nMessage to decrypt: \")\n            print(\"Decrypted Message: {}\".format(\n                decrypt_using_aes_ecb(message, aes_key)))\n\n        elif choice == '3':\n            new_passphrase = input(\"\\nNew passphrase (currently {}): \".format(passphrase))\n            try:\n                if len(new_passphrase) == 0:\n                    raise Exception(\"Password cannot be empty\")\n            except ValueError:\n                print(\"Password cannot be empty\")\n            else:\n                passphrase = new_passphrase\n                aes_key = kdf(passphrase)\n        \n        elif choice == '4': \n            exit()\n\n        else:\n            print(\"Unknown option {}.\".format(choice))\nThe following is the output of the command pip freeze on Python 3.10.6:\ncffi==1.15.1\ncryptography==39.0.0\ngmpy2==2.1.5\npycparser==2.21\nThe following video shows a session with the above program:"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.6.html",
    "href": "Ch3_Symmetric_Encryption/3.6.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.6: SENDING BOB A MESSAGE\nUsing either a modification of the preceding program or your AES encryptor from the beginning of the chapter, create a couple of meetup messages from Alice to Bob. Also create a few from Bob to Alice. Make sure that you can correctly encrypt and decrypt the messages.\n\n\n# Suppose the following code is in a file named: ex3_6.py \n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\n\nclass Padding:\n    @staticmethod    \n    def pad_it_up(msg: bytes) -&gt; bytes: \n        '''\n        This function is used to pad the message.\n\n        Technique: Determine the number of padding bytes required.\n        This is a number n which satisfies 1 &lt;= n &lt;= 16\n        and n + len(msg) is a multiple of 16. Pad the plaintext by appending\n        n bytes, each with value n. (Read more in Chapter 4 of the book  \n        \"Cryptography Engineering by Niels Ferguson, Bruce Schneier, Tadayoshi Kohno\".)\n        ''' \n        n = 16 - len(msg) % 16\n        return msg + bytes([n] * n)\n    \n    @staticmethod\n    def unpad_it_up(msg: bytes) -&gt; bytes: \n        '''this function is used to remove the pads from the message''' \n        n = msg[-1]\n        # then ignore the last n bytes\n        return msg[:-1*n]\n\n# Alice and Bob's Shared Key \ntest_key = bytes.fromhex('00112233445566778899AABBCCDDEEFF')\n\ndef encrypt_using_aes_ecb(plaintext: str, key: bytes) -&gt; str: \n    proper_plaintext = Padding.pad_it_up(plaintext.encode('utf-8'))\n    aesCipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n    aesEncryptor = aesCipher.encryptor()\n    ciphertext = aesEncryptor.update(proper_plaintext)\n    return ciphertext.hex(chr(10),-16) # this will insert '\\n' between every 16-byte block. \n\ndef decrypt_using_aes_ecb(ciphertext: str, key: bytes) -&gt; str: \n    proper_ciphertext = bytes.fromhex(ciphertext.replace('\\n',''))\n    aesCipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n    aesDecryptor = aesCipher.decryptor()\n    plaintext = aesDecryptor.update(proper_ciphertext)\n    plaintext = Padding.unpad_it_up(plaintext)\n    return plaintext.decode()\n\ndef EATSAform(from_codename: str, to_codename: str, date: str, location: str, time: str): \n    # Note that EATSA stands for East Antarctica Truth Spying Agency üòâ\n    return f\"FROM: FIELD AGENT {from_codename}\\n\" \\\n    f\"TO: FIELD AGENT {to_codename}\\n\" \\\n    f\"RE: Meeting\\n\" \\\n    f\"DATE: {date}\\n\" \\\n    f\"\\nMeet me today at the {location} at {time}.\"\nFirst generate the messages:\n\nThen encrypt both of the messages:\n\nLook at the two ciphertext outputs of these messages side-by-side.\n\n\n\nNo\nCiphertext 1 Blocks\nCiphertext 2 Blocks\n\n\n\n\n1\ne5423e662cb98ca3ecf2c66b31cf1c8b\ne5423e662cb98ca3ecf2c66b31cf1c8b\n\n\n2\nf7c240c61a9c1453aae2edb028fa8459\nf7c240c61a9c1453aae2edb028fa8459\n\n\n3\n3d6ec4443f76ebc5a8abb94879113e58\n3d6ec4443f76ebc5a8abb94879113e58\n\n\n4\n88191d257c5970af6774a9f696681766\n88191d257c5970af6774a9f696681766\n\n\n5\n9473f734c616d05dae998037a11f67ab\na9f7e4995ec96761b811c24953c19907\n\n\n6\nee0c3ea2b40c09d80e9558cacf1a60ef\nf70cc1a151a388f34c59b7b83ae0fb08\n\n\n7\n66651c2dc32f4c25f276968d8efda22d\n4d91ea64099f6cb3dea4d1c0edcab02f\n\n\n8\n[empty]\n5a31ed03bf733b150ca46118d8fd8e95\n\n\n\nNote that the first 4 ciphertext blocks are the same.\nRemember that AES in its raw mode is like a code book. For every input and key, there is exactly one output, independent of any other inputs. Thus, because much of the message header is shared between messages, much of the output is also the same.\nLast step, check if the ciphertexts decrypt correctly:\n\nOr:"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.8.html",
    "href": "Ch3_Symmetric_Encryption/3.8.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.8: XOR EXERCISE\nBecause we will use XOR so much, it‚Äôs a good idea to get comfortable with XOR operations. In a Python interpreter, XOR a few numbers together. Python supports XOR directly using ^ as the operator. So, for example, 5^9 results in 12. What do you get when you try 12 ^ 9? What do you get when you try 12 ^ 5? Try this out with several different numbers.\n\n\nSince we know that 5^9 = 12, we can deduce that\n12 ^ 9 = (5 ^ 9) ^ 9 = 5 ^ (9 ^ 9) = 5 ^ 0 = 5\nand\n12 ^ 5 = (5 ^ 9) ^ 5 = (9 ^ 5) ^ 5 = 9 ^ (5 ^ 5) = 9 ^ 0 = 9\n\nFun facts abot XOR:\n\nXOR can be considered as the addition-modulo \\(2\\) operator in \\(\\Z _2\\) and hence satisfies the following properties:\n\nAssociativity: (a ^ b) ^ c = a ^ (b ^ c)\nIdentity Element: 0\nCommutativity: a ^ b = b ^ a\nThe inverse of bit 0 is 0. The inverse of bit 1 is 1.\n\na ^ a = 0\na ^ 0 = a\n\nGood articles about XOR: 1. https://accu.org/journals/overload/20/109/lewin_1915/ 2. https://florian.github.io/xor-trick/"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.10.html",
    "href": "Ch3_Symmetric_Encryption/3.10.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.10: DETERMINISTIC OUTPUT\nRun the same inputs through AES-CBC using the same key and IV. You can use Listing 3-7 as a starting point. Change the inputs to be the same each time and print out the corresponding ciphertexts. What do you notice?\n\n\nI only changed a single line from Listing 3-7. More specifically, I changed this\nfor c in ciphertexts:\n    print(\"Recovered\", manager.decrypt_message(c))\nto this:\nfor c in ciphertexts:\n    print(f\"Ciphertext: {c.hex()} Recovered: \", manager.decrypt_message(c))\nWhen we run the new code, we get the following:\n\nOne thing that we notice from the above screenshot is that, for a given plaintext we get different ciphertext if we vary the key and IV."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.5.html",
    "href": "Ch3_Symmetric_Encryption/3.5.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.5: ALL NIST KATS\nWrite a program that will read one of these NIST KAT ‚Äúrsp‚Äù files, and parse out the encryption and decryption KATs. Test and validate your AES library on all vectors on a couple of ECB test files.\n\n\n# ex3_5.py \n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom colorama import Fore, Style \nimport sys \nimport os \n\ndef encrypt_using_aes_ecb(plaintext: bytes, key: bytes) -&gt; bytes: \n    aesCipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n    aesEncryptor = aesCipher.encryptor()\n    ciphertext = aesEncryptor.update(plaintext)\n    return ciphertext \n\ndef decrypt_using_aes_ecb(ciphertext: bytes, key: bytes) -&gt; bytes: \n    aesCipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())\n    aesDecryptor = aesCipher.decryptor()\n    plaintext = aesDecryptor.update(ciphertext)\n    return plaintext\n\nclass ASingleKAT:\n    def __init__(self, count: int, key: bytes, plaintext: bytes, ciphertext: bytes):\n        self.count = count\n        self.key = key\n        self.plaintext = plaintext \n        self.ciphertext = ciphertext \n    \n    def testInEncryptMode(self): \n        result = encrypt_using_aes_ecb(plaintext=self.plaintext, key=self.key)\n        if result == self.ciphertext: \n            print(Fore.GREEN + f\"Test {self.count} passed!\")\n            print(Style.RESET_ALL, end='')\n        else: \n            print(Fore.RED + f\"Test {self.count} Failed!\")\n            print(Style.RESET_ALL, end='')\n            \n    def testInDecryptMode(self): \n        result = decrypt_using_aes_ecb(ciphertext=self.ciphertext, key=self.key)\n        if result == self.plaintext: \n            print(Fore.GREEN + f\"Test {self.count} passed!\")\n            print(Style.RESET_ALL, end='')\n        else: \n            print(Fore.RED + f\"Test {self.count} Failed!\")\n            print(Style.RESET_ALL, end='')\n    \n    @staticmethod \n    def correctType(kat: dict[str,str]): \n        kat['count'] = int(kat['count'])\n        kat['key'] = bytes.fromhex(kat['key'])\n        kat['plaintext'] = bytes.fromhex(kat['plaintext'])\n        kat['ciphertext'] = bytes.fromhex(kat['ciphertext'])\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2: \n        print(f\"Usage: python3 {sys.argv[0]} &lt;filename&gt;.rsp\")\n        exit(-1) \n    filename = sys.argv[1]\n    if not os.path.exists(filename): \n        print(f\"File {filename} does not exist!\")\n        exit(-1) \n    with open(filename, 'r') as f: \n        encrypt_mode = True\n\n        while True:\n            single_line = f.readline() \n            if single_line == '': \n                # end of file is reached. \n                break \n            if single_line.startswith('#'): \n                # this line is a comment. So ignore it. \n                continue \n            single_line = single_line.strip() \n            if len(single_line) == 0: \n                # this line is an empty line. \n                continue \n            if single_line == \"[ENCRYPT]\": \n                encrypt_mode = True \n                continue \n            if single_line == \"[DECRYPT]\": \n                encrypt_mode = False \n                continue \n            if single_line.startswith('COUNT'):\n                kat = { \n                    \"count\": None, \n                    \"key\": None, \n                    \"plaintext\": None, \n                    \"ciphertext\": None, \n                } \n                for _ in range(4):\n                    data = list(map(lambda x:x.strip(), single_line.split('=')))\n                    kat[data[0].lower()] = data[1]\n                    single_line = f.readline() \n                ASingleKAT.correctType(kat=kat)\n                kat = ASingleKAT(**kat)\n                if encrypt_mode: \n                    kat.testInEncryptMode()\n                else: \n                    kat.testInDecryptMode()\nThe beginning of these NIST KAT files look as follows:\n# CAVS 11.1\n# Config info for aes_values\n# AESVS VarKey test data for ECB\n# State : Encrypt and Decrypt\n# Key Length : 256\n# Generated on Fri Apr 22 15:11:30 2011\n\n[ENCRYPT]\n\nCOUNT = 0\nKEY = 8000000000000000000000000000000000000000000000000000000000000000\nPLAINTEXT = 00000000000000000000000000000000\nCIPHERTEXT = e35a6dcb19b201a01ebcfa8aa22b5759\n\nCOUNT = 1\nKEY = c000000000000000000000000000000000000000000000000000000000000000\nPLAINTEXT = 00000000000000000000000000000000\nCIPHERTEXT = b29169cdcf2d83e838125a12ee6aa400\n\nCOUNT = 2\nKEY = e000000000000000000000000000000000000000000000000000000000000000\nPLAINTEXT = 00000000000000000000000000000000\nCIPHERTEXT = d8f3a72fc3cdf74dfaf6c3e6b97b2fa6\n\nCOUNT = 3\nKEY = f000000000000000000000000000000000000000000000000000000000000000\nPLAINTEXT = 00000000000000000000000000000000\nCIPHERTEXT = 1c777679d50037c79491a94da76a9a35\n\n# and goes on and on and on....\nRunning the above program, we get the following:\n \nYou can download these ‚Äúrsp‚Äù files from https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/aes/KAT_AES.zip"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.15.html",
    "href": "Ch3_Symmetric_Encryption/3.15.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.15: RIDING THE KEYSTREAM\nPut into practice this keystream-stealing attack. That is, encrypt two different purchase messages using the same key and IV. ‚ÄúIntercept‚Äù one of the two messages and XOR the ciphertext contents with the known plaintext. This will give you a keystream. Next, XOR the keystream with the other message to recover that message‚Äôs plaintext. The message sizes may be a little different, but if you‚Äôre short some keystream bytes, recover what you can.\n\n\nSuppose the following code is inside of a file called ex3_15.py.\n# ex3_15.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os \n\nclass CTR: \n    def __init__(self): \n        self.preshared_key = bytes.fromhex(\"6ae8ec45144e0e1f7557c47e0414b5e4\")\n        self.preshared_iv = bytes.fromhex(\"0156b06a05b32e0da4b84e20bbb8e2a6\")\n\n        self.aesContext = Cipher(\n            algorithm=algorithms.AES(self.preshared_key),\n            mode=modes.CTR(self.preshared_iv), \n            backend=default_backend(),\n        )\n        self.encryptor = self.aesContext.encryptor()\n        self.decryptor = self.aesContext.decryptor() \n\ndef generate_msg(merchant: str, buyer: str, date: str, amount: str, cc: str): \n    return \"&lt;XML&gt;\\n\"\\\n    \"&lt;CreditCardPurchase&gt;\\n\"\\\n    f\"&lt;Merchant&gt;{merchant}&lt;/Merchant&gt;\\n\"\\\n    f\"&lt;Buyer&gt;{buyer}&lt;/Buyer&gt;\\n\"\\\n    f\"&lt;Date&gt;{date}&lt;/Date&gt;\\n\"\\\n    f\"&lt;Amount&gt;{amount}&lt;/Amount\\n\"\\\n    f\"&lt;CCNumber&gt;{cc}&lt;/CCNumber&gt;\\n\"\\\n    \"&lt;/CreditCardPurchase&gt;\\n\"\\\n    \"&lt;/XML&gt;\"\n\nmsg1 = generate_msg(\n    merchant=\"Acme Inc\", \n    buyer=\"John Smith\", \n    date=\"01/01/2001\", \n    amount=\"$100.00\", \n    cc=\"555-555-555-555\"\n)\n\nmsg2 = generate_msg(\n    merchant=\"HelloWorld INC\", \n    buyer=\"Harry Potter\", \n    date=\"01/01/2091\", \n    amount=\"$340.00\", \n    cc=\"555-555-555-678\"\n)\n\n\n# the following function is taken from Exercise 3.9. \ndef xor_two_byte_strings(x: bytes, y: bytes) -&gt; bytes: \n    assert(len(x) == len(y))\n    \n    result = []\n    for _1, _2 in zip(x, y): \n        result.append(_1 ^ _2)\n    return bytes(result)\nNow, open up an interactive python interpreter and import it: \nThen encrypt msg1 and msg2 using AES-CTR: \nSuppose now, the attacker knows msg1 and ciphertext_1. Thus he can generate the beginning parts of the keystream as follows: \nThe following screenshot shows how the attacker can hack into ciphertext_2 (or at least the first 196 bytes of it). \nSince the attacker knows the first 196 bytes of the keystream, he can hack into the first 196 bytes of any ciphertext that gets encrypted by the CTR class given above.\nNote that the major flaw in this operation was that the programmers used the same key/IV pair for encrypting two different messages."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Cryptography in Python Answers",
    "section": "",
    "text": "Solutions to the book ‚ÄúPractical Cryptography in Python‚Äù\n\n\n\nPCIP\n\n\nHere is a link to the book."
  },
  {
    "objectID": "Ch5_Message_Integrity_Signatures_and_Certificates/5.1.html",
    "href": "Ch5_Message_Integrity_Signatures_and_Certificates/5.1.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 5.1: TRUST BUT VERIFY\nFinish out the code of the simple encryption plus hash system and add a decryption operation. The decryption operation should, upon finalization, recompute the hash of the ciphertext and compare it to the hash that was sent over. If the hashes don‚Äôt match, it should raise an exception. Be careful! The MAC is not encrypted and should not be decrypted! If you don‚Äôt think carefully about this, you might decrypt data that doesn‚Äôt exist!\n\n\n# ex5_1.py \n\n# FAKE MAC WITH SYMMETRIC ENCRYPTION \nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes \nfrom cryptography.hazmat.backends import default_backend \nimport os, hashlib \n\nclass MessageWasTamperedWithError(Exception): \n    pass \n\nclass Encryptor: \n    def __init__(self, key, nonce): \n        aesContext = Cipher(algorithms.AES(key), modes.CTR(nonce), backend=default_backend())\n        self.encryptor = aesContext.encryptor()\n        self.hasher = hashlib.sha256()\n\n    def update_encryptor(self, plaintext): \n        ciphertext = self.encryptor.update(plaintext) \n        self.hasher.update(ciphertext) \n        return ciphertext \n\n\n    def finalize_encryptor(self): \n        return self.encryptor.finalize() + self.hasher.digest() \n\nclass Decryptor: \n    def __init__(self, key: bytes, nonce: bytes, digest: bytes): \n        aesContext = Cipher(algorithms.AES(key), modes.CTR(nonce), backend=default_backend())\n        self.decryptor = aesContext.decryptor() \n        self.hasher = hashlib.sha256() \n        self.digest = digest\n    \n    def update_decryptor(self, ciphertext: bytes): \n        plaintext = self.decryptor.update(ciphertext) \n        self.hasher.update(ciphertext) \n        return plaintext \n\n    def finalize_decryptor(self): \n        if self.hasher.digest() != self.digest:\n            print(self.hasher.digest(), '\\n' ,self.digest)\n            raise MessageWasTamperedWithError()\n        return self.decryptor.finalize()\n    \n    @staticmethod\n    def get_mac(ciphertext: bytes): \n        return ciphertext[-32:]\n\n\nif __name__ == '__main__': \n    key = os.urandom(32)\n    nonce = os.urandom(16) \n\n    encryptionManager = Encryptor(key, nonce) \n    plaintext = b\"Hi Bob, this is Alice !\"\n    ciphertext = encryptionManager.update_encryptor(plaintext)\n    ciphertext += encryptionManager.finalize_encryptor() \n    \n    decryptionManager = Decryptor(key=key, nonce=nonce, digest=Decryptor.get_mac(ciphertext))\n    _plaintext = decryptionManager.update_decryptor(ciphertext=ciphertext[:-32])\n    _plaintext += decryptionManager.finalize_decryptor() \n\n    assert(plaintext == _plaintext) \n    \n    print(\"[+] Successful!!\")\nWhen you run the above code multiple times, you get the following:"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.6.html",
    "href": "Ch4_Asymmetric_Encryption/4.6.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.6: DICTIONARY ATTACKS\nIt should be pretty clear that it will take longer than your probable attention span to try all possible lowercase ASCII words of length much greather than four or five. But we already saw this same problem in previous chapters. Let‚Äôs try the same solutions. Modify your brute-force program to take a dictionary as input for trying arbirary English words.\n\n\nWe just have to change the generate function inside of ex4_4.py (look at solution of Exercise 4.4).\nThe following might be a good replacement:\ndef generate(dictionary_path: str): \n    with open(dictionary_path, 'r') as f: \n        for single_line in f: \n            yield single_line\n    return"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.14.html",
    "href": "Ch4_Asymmetric_Encryption/4.14.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.14: STAYING UP TO DATE\nDespite the fact that this attack is over \\(20\\) years old, it continues to haunt the internet. Do a little Google searching and find out about the current state of this attack both in terms of prevention and updated variants. Make sure to find out about the ROBOT attack. We‚Äôll talk about this one again when we discuss TLS.\n\n\nIn the original paper published by Daniel Bleichenbacher (Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PCKS #1), he outlines some ways to prevent the attack in the Conclusion section of the paper:\n‚Äù We conclude not only that it is important to include a strong integrity check into an RSA encryption, but also that this integrity check must be perfomed in the correct step of the protocol ‚Äì preferably immediately after decryption. The phase between decryption and integrity check is critical, because even sending out error messages can present a security risk. We also believe that we have provided a strong argument to use plaintext-aware encryption schemes, such as the one described by Bellare and Rogaway. Note that plaintext awareness implies security against chosen-ciphertext attacks. In particular, Version 2 of PKCS #1, which makes use [3] is not susceptible to the attack described in this paper. ‚Äù\nHe closed the paper by saying:\n‚Äù It is a good idea to have a receiver check the integrity of a message immediately after decrypting that message. Even better is to check integrity before decrypting a message, as Cramer and Shoup show is possible [4] ‚Äù\nIf you want to know more about the ROBOT attack, head on over to: https://robotattack.org/"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.12.html",
    "href": "Ch4_Asymmetric_Encryption/4.12.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.12: RUN THE ATTACK!\nTake the preceding code and run some experiments with breaking RSA encryption with PKCS padding. You should use the cryptography module to create the encrypted message, convert the encrypted message to an integer, and then use your attack program (and fake oracle) to break the encryption. To begin with, test your program on RSA keys of size \\(512\\). This breaks faster and will enable you to validate your code sooner.\n\n\nStep 1: Bob generates his private and public key pair (with key size 512 bits).\n\nStep 2: Alice encrypts some data using bob‚Äôs public key.\n\nStep 3: The oracle is assumed to be there, so create it‚Ä¶\n\nStep 4: Eve intercepts Alice‚Äôs ciphertext and uses the oracle to launch the attack.\n\nThis was the key that was used in the above session:\n-----BEGIN RSA PRIVATE KEY-----\nMIIBOgIBAAJBAMQUroKvn1wLSUc89j+astBaazM6CkMbTXpL5T7DdiTxdrcHto/W\nqnDPVoXnvR79RSyJMe1DliI5cZMeXrmccp0CAwEAAQJASYOjhfXIXp8QozfU7zXV\n0s4DoRoinNRQsQhhc62ezuxc3im+JYK1NE1tlTdi/WDQs4wvxT9LZmBwYbWZ0A7A\n9QIhAOKP0ab3kRRigEnCSCweLGqi/DbNQI3uoQePRi9p5gTLAiEA3Y73K35h9aCX\npi86ldxczvKla4y12nTBkiLfLkiR4TcCIBeyoWRMiuFN+Es+xhvPQCgbSjRVPcZa\nyn8m7llxQz0HAiEAkbCMGf6ePd2fOvk9hgQEx1TJsAI0JvW1v/nMVmwD+VsCIEo2\no9Jh/A6fb5OEnSn89d9wYd4aqjT+FAVuFZl1zIWd\n-----END RSA PRIVATE KEY-----\nThis was the main.py file used in the above session:\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey, RSAPublicKey\nfrom cryptography.hazmat.primitives import hashes,serialization \nfrom cryptography.hazmat.backends import default_backend \nimport gmpy2 \n\nfrom collections import namedtuple \n\nInterval = namedtuple('Interval', ['a', 'b']) \n\ndef simple_rsa_encrypt(m, public_key): \n    numbers = public_key.public_numbers() \n    return gmpy2.powmod(m, numbers.e, numbers.n)\n\ndef simple_rsa_decrypt(c: int, private_key): \n    numbers = private_key.private_numbers() \n    return gmpy2.powmod(c, numbers.d, numbers.public_numbers.n)\n\ndef int_to_bytes(i, min_size=None):\n    # i might be a gmpy2 big integer; convert back to a Python int. \n    i = int(i) \n    b = i.to_bytes((i.bit_length()+7)//8, byteorder='big')\n    if min_size != None and len(b) &lt; min_size: \n        b = b'\\x00'*(min_size - len(b)) + b \n    return b \n\ndef bytes_to_int(b): \n    return int.from_bytes(b, byteorder='big')\n\nclass Oracle: \n    pass \n\nclass FakeOracle(Oracle): \n    def __init__(self, private_key): \n        self.private_key = private_key \n    \n    def __call__(self,cipher_text:int)-&gt; bool : \n        recovered_as_int = simple_rsa_decrypt(cipher_text, private_key=self.private_key)\n        recovered = int_to_bytes(recovered_as_int, min_size=self.private_key.key_size//8) \n        return recovered[:2] == bytes([0, 2])\n    \n\nclass RSAOracleAttacker: \n    def __init__(self, public_key: RSAPublicKey, oracle: Oracle): \n        self.public_key = public_key \n        self.oracle = oracle \n    \n    def _step1_blinding(self, c): \n        self.c0 = c \n        \n        self.B = 2 ** (self.public_key.key_size - 16)\n        self.s = [1] \n        self.M = [ \n            [Interval(2 * self.B, 3 * self.B - 1)],\n        ]\n\n        self.i = 1 \n        self.n = self.public_key.public_numbers().n \n    \n    def _find_s(self, start_s, s_max = None): \n        si = start_s \n        ci = simple_rsa_encrypt(si, self.public_key) \n\n        while not self.oracle((self.c0 * ci) % self.n):\n            si += 1 \n\n            if s_max and (si &gt; s_max): \n                return None \n            \n            ci = simple_rsa_encrypt(si, self.public_key) \n\n        return si \n    \n    def _step2a_start_the_searching(self): \n        si = self._find_s(start_s=gmpy2.c_div(self.n, 3 * self.B))\n        return si \n    \n    def _step2b_searching_with_more_than_one_interval(self): \n        si = self._find_s(start_s=self.s[-1] + 1) \n        return si \n    \n    def _step2c_searching_with_one_interval_left(self): \n        a, b = self.M[-1][0]\n        ri = gmpy2.c_div(2*(b*self.s[-1] - 2 * self.B), self.n) \n        si = None \n\n        while si == None: \n            si = gmpy2.c_div((2*self.B + ri * self.n), b) \n            s_max = gmpy2.c_div((3 * self.B + ri * self.n), a) \n            si = self._find_s(start_s = si, s_max = s_max) \n            ri += 1 \n        \n        return si \n    \n    def _step3_narrowing_set_of_solutions(self, si): \n        new_intervals = set() \n        for a, b in self.M[-1]: \n            r_min = gmpy2.c_div((a*si - 3 * self.B + 1), self.n) \n            r_max = gmpy2.f_div((b*si - 2 * self.B), self.n) \n\n            for r in range(r_min, r_max + 1): \n                a_candidate = gmpy2.c_div((2 * self.B + r * self.n), si) \n                b_candidate = gmpy2.f_div((3 * self.B-1 + r * self.n), si) \n\n                new_interval = Interval(max(a, a_candidate), min(b, b_candidate)) \n\n                new_intervals.add(new_interval) \n        \n        new_intervals = list(new_intervals) \n        self.M.append(new_intervals) \n        self.s.append(si) \n\n        if len(new_intervals) == 1 and new_intervals[0].a == new_intervals[0].b: \n            return True \n    \n        return False \n\n    def _step4_computing_the_solution(self): \n        interval = self.M[-1][0] \n        return interval.a \n    \n    def attack(self, c): \n        self._step1_blinding(c) \n\n        # do this until there is one interval left \n        finished = False \n        while not finished: \n            if self.i == 1: \n                si = self._step2a_start_the_searching()\n            elif len(self.M[-1]) &gt; 1: \n                si = self._step2b_searching_with_more_than_one_interval() \n            elif len(self.M[-1]) == 1: \n                interval = self.M[-1][0]\n                si = self._step2c_searching_with_one_interval_left() \n            \n            finished = self._step3_narrowing_set_of_solutions(si) \n            self.i += 1 \n        \n        m = self._step4_computing_the_solution() \n        return m"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.1.html",
    "href": "Ch4_Asymmetric_Encryption/4.1.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.1: SIMPLE RSA ENCRYPTION\nUsing the preceding application, set up communication from Alice to Bob and then send a few encrypted messages from Alice to Bob for decryption.\n\n\nHere is a 2 minute youtube video explaining it all.\nIn the video, you will see that Alice generates her private and public key pair. Bob then uses Alice‚Äôs public key and sends her encrypted messages. Alice will then decrypt the messages she received from Bob by using her private key.\n\n\n\nHere is a 2 minute youtube video explaining it all.\n\n\n# listing4_4.py\nimport gmpy2,os, binascii\nfrom cryptography.hazmat.backends import default_backend \nfrom cryptography.hazmat.primitives.asymmetric import rsa \nfrom cryptography.hazmat.primitives import serialization \n\n\n#### DANGER ####\n# THE FOLLOWING RSA ENCRYPTION AND DECRYPTION IS COMPLETELY UNSAFE AND \n# TERRIBLY BROKEN. DO NOT USE FOR ANYTHING OTHER THAN THE PRACTICE \n# EXERCISE\n################\ndef simple_rsa_encrypt(m, public_key): \n    numbers = public_key.public_numbers() \n    return gmpy2.powmod(m, numbers.e, numbers.n)\n\ndef simple_rsa_decrypt(c, private_key): \n    numbers = private_key.private_numbers() \n    return gmpy2.powmod(c, numbers.d, numbers.public_numbers.n)\n\ndef int_to_bytes(i):\n    # i might be a gmpy2 big integer; convert back to a Python int. \n    i = int(i) \n    return i.to_bytes((i.bit_length()+7)//8, byteorder='big')\n\ndef bytes_to_int(b): \n    return int.from_bytes(b, byteorder='big')\n\ndef main(): \n    public_key_file = None \n    private_key_file = None \n    public_key = None \n    private_key = None \n\n    while True: \n        print(\"Simple RSA Crypto\") \n        print(\"------------------\")\n        print(\"\\tprivate key file: {}\".format(private_key_file))\n        print(\"\\tpublic_key_file: {}\".format(public_key_file)) \n        print(\"\\t1. Encrypt Message\")\n        print(\"\\t2. Decrypt Message.\")\n        print(\"\\t3. Load public key file \")\n        print(\"\\t4. Load private key file.\") \n        print(\"\\t5. Create and load new public and private key files.\")\n        print(\"\\t6. Quit.\\n\")\n\n        choice = input(\"&gt;&gt; \") \n\n        if choice == \"1\": \n            if not public_key: \n                print(\"\\nNo public key loaded\\n\") \n            else: \n                message = input(\"\\nPlaintext: \").encode() \n                message_as_int = bytes_to_int(message) \n                cipher_as_int = simple_rsa_encrypt(message_as_int, public_key)\n                cipher = int_to_bytes(cipher_as_int) \n                print(\"\\nCiphertext (hexlified): {}\\n\".format(binascii.hexlify(cipher)))\n        elif choice == '2':\n            if not private_key: \n                print(\"\\nNo private key loaded\\n\")\n            else: \n                cipher_hex = input(\"\\nCiphertext (hexlified): \").encode() \n                cipher = binascii.unhexlify(cipher_hex)\n                cipher_as_int = bytes_to_int(cipher) \n                message_as_int = simple_rsa_decrypt(cipher_as_int, private_key)\n                message = int_to_bytes(message_as_int) \n                print(\"\\nPlaintext: {}\\n\".format(message)) \n        elif choice == '3': \n            public_key_temp_file = input(\"\\nEnter public key file: \")\n            if not os.path.exists(public_key_temp_file): \n                print(f\"File {public_key_temp_file} does not exist.\")\n                continue \n            with open(public_key_temp_file, 'rb') as f: \n                public_key = serialization.load_pem_public_key(\n                    data=f.read(),\n                    backend=default_backend()\n                )\n                public_key_file = public_key_temp_file\n                print(\"\\nPublic Key file loaded.\\n\")\n\n                # unload private key if any\n                private_key_file = None \n                private_key = None \n        elif choice == '4':\n            private_key_file_temp = input(\"\\nEnter private key file: \")\n            if not os.path.exists(private_key_file_temp):\n                print(f\"File {private_key_file_temp} does not exist.\")\n                continue \n            with open(private_key_file_temp, 'rb') as f: \n                private_key = serialization.load_pem_private_key(\n                    data=f.read(),\n                    backend=default_backend(),\n                    password=None\n                ) \n                private_key_file = private_key_file_temp \n                print(\"\\nPrivate Key file loaded.\\n\") \n\n                # load public key for the given private key \n                # (unload previous public key if any) \n                public_key = private_key.public_key() \n                public_key_file = None \n        elif choice == '5': \n            private_key_file_temp = input(\"\\nEnter a file name for new private key: \") \n            public_key_file_temp = input(\"\\nEnter a file name for a new public key: \") \n            \n            if os.path.exists(private_key_file_temp) or os.path.exists(public_key_file_temp): \n                print(\"File already exists\") \n                continue\n\n            with open(private_key_file_temp, \"wb+\") as private_key_file_obj: \n                with open(public_key_file_temp, \"wb+\") as public_key_file_obj: \n                    private_key = rsa.generate_private_key(\n                        public_exponent=65537, \n                        key_size=2048, \n                        backend=default_backend(),\n                    )\n                    public_key = private_key.public_key() \n\n                    private_key_file_obj.write(\n                        private_key.private_bytes(\n                            encoding=serialization.Encoding.PEM, \n                            format=serialization.PrivateFormat.TraditionalOpenSSL, \n                            encryption_algorithm=serialization.NoEncryption(), \n                        )\n                    )\n\n                    public_key_file_obj.write(\n                        public_key.public_bytes(\n                            encoding=serialization.Encoding.PEM, \n                            format=serialization.PublicFormat.SubjectPublicKeyInfo,\n                        )\n                    )\n\n                    public_key_file = None \n                    private_key_file = private_key_file_temp\n        elif choice == '6':\n            print(\"\\n\\nTerminating. This program will self destruct in 5 seconds. \\n\")\n            break\n        else: \n            print(\"\\n\\nUnknown Option {}.\\n\".format(choice))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.2.html",
    "href": "Ch4_Asymmetric_Encryption/4.2.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.2: WHO GOES THERE? BOB? IS THAT YOU?\nAssume the role of Eve and imagine that you know everything about Alice‚Äôs and Bob‚Äôs operation except the private key. That is, suppose you know about the classified ads, the carrier penguins, and even the encryption program. \\(^5\\) Their scheme is strengthened by using asymmetric encryption, but is still vulnerable to a MITM (man-in-the-middle) attack. How can Eve position herself such that she can trick Alice into sending messages that Eve can decrypt, and Bob into receiving only false messages from Eve instead of Alice?\n\\(^5\\) Remember Kerckhoff‚Äôs principle? Here it is again!\n\n\nWell, Eve can generate her own keys (lets suppose they are stored in the files eve_private_key.txt and eve_public_key.txt). Then she advertises her public key (eve_public_key.txt) as if it is Bob‚Äôs public key.\nAlice will use Eve‚Äôs public key (thinking she is using the correct Bob‚Äôs public key) , encrypt her messages and sends them off. Eve being the MITM, will intercept this message and decrypt it (she can do this because it is encrypted by her public key).\nThen Eve can edit the message sent by Alice, and re-encrypt the edited message by using Bob‚Äôs public key. She then sends this ciphertext to Bob as if it came from Alice."
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.8.html",
    "href": "Ch4_Asymmetric_Encryption/4.8.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.8: EVE‚ÄôS PROTEGE\nRecreate Eve‚Äôs chosen ciphertext attack. Create a sample message in Python, as you have done previously, using the public key to encrypt it. Then, encrypt a value of \\(r\\) (such as \\(2\\)). Multiply the two numeric versions of the ciphertext together and don‚Äôt forget to take the answer modulo \\(n\\). Decrypt this new ciphertext and try to convert it to bytes. It shouldn‚Äôt be anything human readable. Take the numeric version of this decryption and multiply it by the inverse of \\(r \\: (\\text{mod} \\: n)\\). You should be back to the orginal number. Convert it to bytes to see the orginal message.\n\n\nHere is a 3 minute youtube video explaining it all.\n\n\n\nHere is a 3 minute youtube video explaining it all."
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.7.html",
    "href": "Ch4_Asymmetric_Encryption/4.7.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.7: HOMOMORPHIC PROPERTY OF UNPADDED RSA\nUse \\((4.3)\\) to multiply two RSA-encrypted numbers together and decrypt the result to verify the equation.\n\n\nSolution is given in Listing 4.5 of the book.\nNo need to copy the solution here."
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.5.html",
    "href": "Ch4_Asymmetric_Encryption/4.5.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.5: WAITING IS THE HARDEST PART\nModify the brute-force program to try all possible words of five or fewer letters. Measure the time it takes (worst case) to brute force a four-letter word vs a five-letter word. About how many times longer does it take and why? How long would it take to try all possible six-letter words?\n\n\nQuestion: How may words can be formed using at most \\(n\\) characters?\n\n\n\nNo of Characters\nNumber of words formed using at most \\(n\\) characters\n\n\n\n\n\\(4\\)\n\\(26 + 26^2 + 26^3 + 26^4 = 475,254\\)\n\n\n\\(5\\)\n\\(26 + 26^2 + 26^3 + 26^4 + 26^5 = 12,356,630\\)\n\n\n\\(6\\)\n\\(26 + 26^2 + 26^3 + 26^4 + 26^5 + 26^6 = 321,272,406\\)\n\n\n\\(n\\)\n\\(\\frac{26}{25}(26^n-1)\\)\n\n\n\n# ex4_5.py\n\nimport string\nimport gmpy2,os, binascii\nfrom cryptography.hazmat.backends import default_backend \nfrom cryptography.hazmat.primitives.asymmetric.types import PublicKeyTypes \nfrom cryptography.hazmat.primitives import serialization \n\n# This module is defined in the solution of Exercise 4.1\nimport listing4_4\n\nimport timeit \n\n# taken from solution of Exercise 2.7\ndef generate(alphabet, max_len):\n    if max_len &lt;= 0: return\n    for c in alphabet:\n        yield c\n    for c in alphabet:\n        for next in generate(alphabet, max_len-1):\n            yield c + next\n\ndef rsa_encrypt(pk, m: str): \n    '''\n    pk: is the public key. \n    m: is the message in strings.\n    '''\n    m = m.encode() \n    m = listing4_4.bytes_to_int(m)\n\n    # c is the ciphertext in integer \n    c = listing4_4.simple_rsa_encrypt(m = m, public_key=pk)\n\n    # change c into bytes. \n    c = listing4_4.int_to_bytes(c)\n\n    # hexlify c and return it.\n    return c.hex()\n\ndef main(public_key_file: str, ciphertext: str, length_of_plaintext: int): \n    public_key = None \n\n    if not os.path.exists(public_key_file):\n        print(\"File does not exist.\")\n        exit(-1)\n    \n    with open(public_key_file, 'rb') as f: \n        public_key = serialization.load_pem_public_key(\n            data=f.read(),\n            backend=default_backend()\n        )\n        print(\"\\nPublic Key file loaded.\\n\")\n\n    for possible_plaintext in generate(alphabet=string.ascii_lowercase, max_len=length_of_plaintext): \n        if rsa_encrypt(pk=public_key, m=possible_plaintext) == ciphertext: \n            # we have successfully found a pre image. \n            print(f\"Plaintext: {possible_plaintext}\")\n            break\n    else: \n        print(\"No preimage found.\")\n\n\nif __name__ == '__main__': \n    public_key_file = input(\"Enter the public key file&gt; \") \n    ciphertext = input(\"Enter the ciphertext&gt; \") \n    max_length = int(input(\"Enter the maximum length of the plaintext&gt; \"))\n    \n    total_execution_time = timeit.timeit(\n        stmt=f\"main(public_key_file='{public_key_file}', ciphertext='{ciphertext}', length_of_plaintext={max_length})\",\n        setup=\"from __main__ import main\",\n        number = 1\n    )\n    print(f\"Time it took in seconds: {total_execution_time} seconds.\")\nWorst case is achieved when the plaintext is zzzz (for the four-letter word case) and zzzzz (for the five-letter word case).\n \nNote that the public key I was using in the above sessions was the same public key I used in Execrsie 4.4.\n\nMeasure the time it takes (worst case) to brute force a four-letter word vs a five-letter word. About how many times longer does it take and why?\n\nAs shown above: * the time it took to bruteforce a four-letter word is about \\(13.27\\) seconds. * the time it took to bruteforce a five-letter word is about \\(375.52\\) seconds.\nThus the time it takes to bruteforce a five-letter word is about the same as \\(28\\) times the time it takes to bruteforce a four-letter word. We got a number closer to \\(26\\) because there are \\(26\\) letters in our alphabet.\n\nHow long would it take to try all possible six-letter words?\n\nMy guess is $10,630 57 $."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Ch2_Hashing/2.9.html",
    "href": "Ch2_Hashing/2.9.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 2.9 PROOF OF WORK\nWrite a program that feeds a counter in SHA-256, taking the output hash and converting it to an integer (we did this earlier before converting to binary). Have the program repeat until it finds a hash that is less than a target number. The target number should start out pretty big, like \\(2^{255}\\). To make this more like blockchain, include some arbitrary bytes to be combined with the counter.\n\n\n# ex2_9.py\n\nimport hashlib\nimport secrets\n\ndef convert_to_decimal(number: str, base: int) -&gt; int:\n    '''\n    Taken from https://github.com/noahabe/numrep/blob/master/numrep.py\n\n    Changes the first parameter (which is expected to be a hexadecimal number)\n    into a base 10 integer. \n    '''\n    ########### [FOR HEXADECIMAL ONLY]############\n    if base == 16:\n        convertion_table = {\n            'A': 10,\n            'B': 11,\n            'C': 12,\n            'D': 13,\n            'E': 14,\n            'F': 15,\n        }\n        def CONVERT(x: str): return convertion_table[x.upper()]\n    #############################################\n    decimal = 0\n    position = len(number)-1\n    for single_digit in number:\n        if single_digit.isalpha():\n            single_digit = CONVERT(single_digit)\n        decimal += int(single_digit) * base**position\n        position -= 1\n    return decimal\n\ndef proof_of_work(random_block: bytes, target_number_exp: int) -&gt; dict[str, str | bytes]:\n    counter = 0\n    target_number = 2 ** target_number_exp\n    try: \n        while True: \n            h = hashlib.sha256()\n            h.update(random_block)\n            h.update(str(counter).encode('utf-8'))\n            if convert_to_decimal(h.hexdigest(), 16) &lt; target_number: \n                return {\n                    \"nonce\": str(counter), \n                    \"hash\": h.hexdigest(),\n                    \"random_block\": random_block[0:3], \n                    \"target_number\": f\"2^{target_number_exp}\"\n                }\n            counter += 1 \n    except KeyboardInterrupt: \n        print(\"Exiting...\")\n        exit()\n\ndef main(start_target_number_exponent: int = 255, end_target_number_exponent: int = 250):\n    # the random_block makes it look more like blockchain\n    random_block = secrets.token_bytes(1000) # 1 Kilobyte of random bytes.\n    for target_number_exp in range(start_target_number_exponent, end_target_number_exponent, -1): \n        retval = proof_of_work(random_block, target_number_exp)\n        print(retval)\n\nif __name__ == '__main__':\n    start_target_number_exponent = int(input(\"Start target number exponent: \"))\n    end_target_number_exponent = int(input(\"End target number exponent: \"))\n    main(start_target_number_exponent, end_target_number_exponent)\nThe following video shows the execution of the above script:"
  },
  {
    "objectID": "Ch2_Hashing/2.6.html",
    "href": "Ch2_Hashing/2.6.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 2.6 THE POWER OF ONE, BUT BIGGER!\nRepeat the previous exercise, but use an increasingly bigger input alphabet set. Try the test with both lowercase and uppercase letters. Then try it with lowercase letters, uppercase letters, and numbers. Finally, try all printable characters (string.printable).\n\nHow many total symbols are in each input set?\nHow much longer does each run take?\n\n\n\n\n\nHow many total symbols are in each input set?\n\n\n\n\n\n\n\n\n\n\nInput set\nPython equivalent\nNumber of total symbols\n\n\n\n\nlowercase and uppercase letters\nstring.ascii_letters\n52\n\n\nlowercase letters, uppercase letters, and numbers\nstring.ascii_letters + string.digits\n62\n\n\nall printable characters\nstring.printable\n100\n\n\n\n\n\nHow much longer does each run take?\n\n\nI used the following code to answer this question:\n# ex2_6.py \n\nimport hashlib\nimport secrets\nimport timeit\nfrom string import ascii_letters, digits, printable\n\npossible_alphabets = {\n    \"ascii_letters\": ascii_letters, \n    \"ascii_letters + digits\": ascii_letters + digits, \n    \"printable\": printable,\n}\n\ndef single_run(alphabet_name: str): \n    alphabet = possible_alphabets[alphabet_name]\n    \n    def h(x: str) -&gt; str:\n        '''returns the md5 digest of the string x.'''\n        return hashlib.md5(x.encode('utf-8')).hexdigest()\n\n    preimage_seed = secrets.choice(alphabet)\n    test_hash = h(preimage_seed)\n\n    for single_letter in alphabet: \n        if h(single_letter) == test_hash: \n            # found a match\n            break\n    return \n\nif __name__ == '__main__':\n    COUNTER = 1_000_000\n\n    for alpha_name, alpha_value in possible_alphabets.items(): \n        total_execution_time = timeit.timeit(\n            stmt=f\"single_run('{alpha_name}')\", \n            setup=\"from __main__ import single_run\", \n            number=COUNTER, \n        )\n        print(f\"Called single_run({alpha_name}) {COUNTER} times. Total execution time (in seconds): {total_execution_time} sec\")\n        print(f\"Average execution time: {total_execution_time/COUNTER} sec\")\n        print(\"\\n--------------------------------\\n\")"
  },
  {
    "objectID": "Ch2_Hashing/2.1.html",
    "href": "Ch2_Hashing/2.1.html",
    "title": ".",
    "section": "",
    "text": "Welcome to MD5\nCompute more digests. Try computing the MD5 sum of the following inputs: * b‚Äôalice‚Äô, * b‚Äôbob‚Äô, * b‚Äôbalice‚Äô, * b‚Äôcob‚Äô, * b‚Äôa‚Äô, * b‚Äôaa‚Äô, * b‚Äôaaaaaaaaaa‚Äô, * b‚Äôa‚Äô*100000\n\n\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; all_data = [b'alice', b'bob', b'balice', b'cob', b'a', b'aa', b'aaaaaaaaaa', b'a'*100_000]\n&gt;&gt;&gt; for single_data in all_data:\n...     print(\"{} {}\".format(hashlib.md5(single_data).hexdigest(), single_data[0:15]))\n...\n6384e2b2184bcbf58eccf10ca7a6563c b'alice'\n9f9d51bc70ef21ca5c14f307980a29d8 b'bob'\n6760742ebf884c998752b4e082b78224 b'balice'\n386685f06beecb9f35db2e22da429ec9 b'cob'\n0cc175b9c0f1b6a831c399e269772661 b'a'\n4124bc0a9335c27f086f24ba207a4912 b'aa'\ne09c80c42fda55f9d992e59ca6b3307d b'aaaaaaaaaa'\n1af6d6f2f682f76f80e606aeaaee1680 b'aaaaaaaaaaaaaaa'\n&gt;&gt;&gt;"
  },
  {
    "objectID": "Ch2_Hashing/2.4.html",
    "href": "Ch2_Hashing/2.4.html",
    "title": "Practical Cryptography In Python",
    "section": "",
    "text": "MD5 OF A FILE\nWrite a python program that computes the MD5 sum of the data in a file. You don‚Äôt need to worry about any of the file‚Äôs metadata, such as last modified time or even the file‚Äôs name, only its contents.\n\n\n# ex2_4.py \n\nimport hashlib\nimport sys\n\ndef md5_a_file(filename: str)-&gt;str:\n    h = hashlib.md5()\n    with open(filename, 'rb') as f: \n        data = f.read(4096)\n        while data != b'': \n            h.update(data)\n            data = f.read(4096)\n    return h.hexdigest() \n\nif __name__ == '__main__': \n    if len(sys.argv) != 2: \n        print(\"Usage: python3 ex2_4.py &lt;filename&gt;\")\n        exit(-1)\n    filename = sys.argv[1]\n    print(md5_a_file(filename))\nThe following shows how to use the above script to md5 a \\(350\\) megabyte video file:\n\nWe can see that, we got the same result, as that of the program md5sum:"
  },
  {
    "objectID": "Ch1_Cryptography_More_Than_Secrecy/1.1.html",
    "href": "Ch1_Cryptography_More_Than_Secrecy/1.1.html",
    "title": "Practical Cryptography In Python",
    "section": "",
    "text": "Exercise 1.1 (Shift Cipher Encoder)\nCreate a Python program that encodes and decodes messages using the shift cipher described in this section. The amount of shift must be configurable.\n\n\nSuppose the following python code is found in a file called ceasar.py.\nfrom string import ascii_uppercase\nimport io\n\nNUM_OF_ALPHABETS = len(ascii_uppercase)\n\ndef core(msg: str, shift: int = 0) -&gt; str: \n    retval = io.StringIO()\n\n    for single_char in msg:\n        if single_char not in ascii_uppercase:\n            retval.write(single_char)\n            continue\n        retval.write(ascii_uppercase[(ascii_uppercase.index(single_char) + shift) % NUM_OF_ALPHABETS])\n\n    contents = retval.getvalue()\n    retval.close()\n    return contents\n\ndef encrypt(msg: str, key: int): \n    assert(key &gt; 0)\n    return core(msg.upper(), key)\n\ndef decrypt(msg: str, key: int): \n    assert(key &gt; 0)\n    return core(msg.upper(), -1 * key)\nUsage:"
  },
  {
    "objectID": "Ch1_Cryptography_More_Than_Secrecy/1.3.html",
    "href": "Ch1_Cryptography_More_Than_Secrecy/1.3.html",
    "title": "Practical Cryptography In Python",
    "section": "",
    "text": "Exercise 1.3 (A strong substitution cipher)\nWhat if instead of shifting the alphabet, you randomly jumbled the letters? Create a program that encodes and decodes messages using this kind of substitution.\nSome newspapers publish puzzles like this called cryptograms.\n\n\nIn cryptography, a substitution cipher is a method of encrypting in which units of plaintext are replaced with the ciphertext, in a defined manner, with the help of a key; the ‚Äúunits‚Äù may be single letters (the most common), pairs of letters, triplets of letters, mixtures of the above, and so forth. The receiver deciphers the text by performing the inverse substitution process to extract the original message. (taken from wikipedia: https://en.wikipedia.org/wiki/Substitution_cipher).\nThe following code is used to generate the key.\n# key.py \n\nimport secrets\nimport string\n\nalphabet = string.ascii_letters + string.digits \n\ndef getRandomChar(): \n    l = list(alphabet)\n    while len(l) &gt; 0: \n        n = secrets.randbelow(len(l))\n        retval = l.pop(n)\n        yield retval \n\ndef getRandomKeyForSubstitutionCipher() -&gt; dict[str, str]:\n    return dict(zip(alphabet, getRandomChar()))\n\ndef reverseKey(key: dict[str, str]) -&gt; dict[str, str]: \n    retval = dict()\n    for k, v in key.items(): \n        retval[v] = k \n    return retval \n\nif __name__ == '__main__': \n    print(getRandomKeyForSubstitutionCipher())\n\n\n# ex1_3.py \n\nimport key as km\n\ndef encrypt(plaintext: str, key: dict[str, str]) -&gt; str: \n    return ''.join(key.get(p,p) for p in plaintext)\n\ndef decrypt(ciphertext: str, key: dict[str, str]) -&gt; str: \n    _key = km.reverseKey(key=key)\n    return encrypt(plaintext=ciphertext, key=_key)"
  },
  {
    "objectID": "Ch1_Cryptography_More_Than_Secrecy/1.6.html",
    "href": "Ch1_Cryptography_More_Than_Secrecy/1.6.html",
    "title": ".",
    "section": "",
    "text": "Exercise 1.6 Brute Force\nTry having your cryptogram-decoding program brute force a message. How long would it take to test every possible mapping? Can you write a program that can speed this up with any kind of ‚Äúsmart guess‚Äù?\n\n\nPossible brute force code:\n# ex1_6.py\n\nimport ex1_5\n\ndef bruteforce(ciphertext: str): \n    for possible_key in range(31469973260387937525653122354950764088012280797258232192163168247821107200000000000000):\n        possible_plaintext = ex1_5.decryptUsingIndex(ciphertext=ciphertext, key=possible_key)\n        x = input(f\"Is this the plaintext you are looking for [{possible_plaintext}] ü§£ [Y][N]:\")\n        if x == 'Y': \n            # we found the plain text we are looking for hooray\n            return \n\nbruteforce(\"hellF PFSld hFP ZHR IOK NOVmw bq NZ7Z0D\")\nRunning the code:\n\nAs you can imagine this will take an awful amount of time.\nNot only that, we can even have ‚Äúfake plaintexts‚Äù. That is plaintext that the attacker thinks is correct but was not the actual plaintext that was sent. This arises when the attacker decrypts the ciphertext with a wrong key and by coincidence the incorrect plaintext contains english words luring the attacker into believing he has found the correct key (even though he didn‚Äôt).\nThe cryptanalysis method Frequency analysis seems to be effective against such ciphers. https://en.wikipedia.org/wiki/Frequency_analysis"
  },
  {
    "objectID": "Ch1_Cryptography_More_Than_Secrecy/1.4.html",
    "href": "Ch1_Cryptography_More_Than_Secrecy/1.4.html",
    "title": ".",
    "section": "",
    "text": "Exercise 1.4 Count the dictionaries\nHow many substitution dictionaries are possible for the cryptogram-style substitution in the previous exercise?\n\n\nNote that the alphabet that was used in the key.py file was\nimport string\n\nalphabet = string.ascii_letters + string.digits \n\nThus, the number of substitution dictionaries that are possible is \\(62! \\approx 2^{284.018}\\)."
  },
  {
    "objectID": "Ch1_Cryptography_More_Than_Secrecy/1.2.html",
    "href": "Ch1_Cryptography_More_Than_Secrecy/1.2.html",
    "title": "Practical Cryptography In Python",
    "section": "",
    "text": "Exercise 1.2: Automated Decoding\nIn our example, Eve tried decoding various messages until she saw something that looked like English. Try automating this.\n\nGet a data structure containing a few thousand English words. \\(^1\\)\nCreate a program that takes in an encoded string, then try decoding it with all 25 shift values.\nUse the dictionary to try to automatically determine which shift is most likely.\n\nBecause you have to deal with messages with no spaces, you can simply keep a count of how many dictionary words show up in the decoded output. Occasionally, one or two words might appear by accident, but the correct decoding should have significantly more hits.\n\\(^1\\) You can find lists of such words online, and your program can automatically populate your data structure with them.\n\n\nThe lists of words I used can be found at https://github.com/dwyl/english-words . More specifically I used the words_alpha.txt file in the repo.\nThe code to perform automated decoding is given below. Note that it uses the caesar.py script given in the answer of exercise 1.1.\nimport caesar as c\nimport sys\n\ndef load_english_words() -&gt; list[str]:\n    '''\n    This function loads all of the english words \n    in the file ~ 370K english words.\n    '''\n    with open('words_alpha.txt') as word_file:\n        english_words = word_file.read().split()\n\n    return english_words\n\ndef generate_the_25_possible_plain_text_values(msg: str) -&gt; list[str]: \n    return [\n        c.decrypt(msg=msg, key=key)\n        for key in range(1, 26)\n    ]\n\ndef automated_decoding(encrypted_msg: str) -&gt; list[dict]: \n    possible_plain_text_values = generate_the_25_possible_plain_text_values(encrypted_msg)\n    english_words = load_english_words()\n\n    likelihood_of_correctness = dict()\n\n    for plain_text in possible_plain_text_values: \n        likelihood_of_correctness[plain_text] = 0\n\n        for english_word in english_words:\n            if plain_text.rfind(english_word.upper()) != -1: \n                likelihood_of_correctness[plain_text] += 1 \n\n    likelihood_of_correctness = sorted(likelihood_of_correctness.items(), key=lambda t:t[1], reverse=True)\n    return [\n        {\n            \"plain text\": _[0], \n            \"english word hits\": _[1], \n            \"key\": possible_plain_text_values.index(_[0]) + 1\n        } \n        for _ in likelihood_of_correctness[:5]\n    ]\n\nif __name__ == '__main__': \n    if len(sys.argv) != 2: \n        print(\"Usage python3 ex1.2.py &lt;encrypted msg&gt;\")\n        exit(-1)\n    top_5_most_likely_plaintexts = automated_decoding(encrypted_msg=sys.argv[1])\n    for possible_plaintext in top_5_most_likely_plaintexts: \n        print(possible_plaintext)\n    \nUsage: (assuming the above script is inside of a file called ex1.2.py)\n\nIf you think you know a better algorithm/data structure to keep all the words, don‚Äôt forget to hit a pull request (or an issue explaining your ideas). üëçüëç\nAnd don‚Äôt forget to use python version 3.10 or above."
  },
  {
    "objectID": "Ch1_Cryptography_More_Than_Secrecy/1.5.html",
    "href": "Ch1_Cryptography_More_Than_Secrecy/1.5.html",
    "title": ".",
    "section": "",
    "text": "Exercise 1.5 Identifying the dictionary\nModify your cryptogram program so that you can identify and pick the jumbled character substitution map with a number. That is, each mapping has a unique number that identifies it: picking substitution \\(n\\) should create the same substitution mapping every time. This exercise is a little tougher than the others. Do your best!\n\n\nLet‚Äôs simplify the problem and consider the set \\(\\{a, b, c\\}\\). Since \\(3! = 6\\) we know that it has \\(6\\) permutations. So, what we want is to assign this \\(6\\) permutations unique numbers starting from \\(0\\) upto \\(5\\). The following tree might help us do just that:\n\nThe intervals written in red, next to the nodes, in the above picture tell us which permutations are under them. Consider the node that has the interval [2..4). The half open interval represents a set: \\([2..4) = \\{2, 3\\}\\). This means that the permutations that have ID \\(2 \\: \\text{and} \\: 3\\) are below it.\n\n\n\npermutations of \\(\\{a, b, c\\}\\)\nNumber that identifies it\n\n\n\n\n\\(a, b, c\\)\n0\n\n\n\\(a, c, b\\)\n1\n\n\n\\(b, a, c\\)\n2\n\n\n\\(b, c, a\\)\n3\n\n\n\\(c, a, b\\)\n4\n\n\n\\(c, b, a\\)\n5\n\n\n\nOkay, let‚Äôs generalize a bit:\n\nGiven an integer \\(z\\) satisfying \\(0 \\leq z &lt; n!\\) , do you think we can traverse this tree from the root node down to leaf node and then return the permutation that corresponds to \\(z\\)?\nThat is exactly what the function _getKeyFromIndex() does in the following code.\n# ex1_5.py \n\nimport string\nfrom math import factorial as f\nimport ex1_3 # look at exercise 1.3\n\nalphabet = string.ascii_letters + string.digits\n\ndef _getKeyFromIndex(z: int) -&gt; str: \n    n = len(alphabet)\n    assert(z &gt;= 0 and z &lt; f(n))\n\n    result = []\n    _alphabet = list(alphabet)\n    while n &gt; 0:\n        q = int(z // f(n-1))\n        result.append(_alphabet.pop(q))\n        z -= q * f(n-1)\n        n = len(_alphabet)\n    \n    return ''.join(result)\n\n\ndef getKeyFromIndex(z: int) -&gt; dict[str, str]: \n    primitive_key = _getKeyFromIndex(z = z)\n    return dict(zip(alphabet, primitive_key)) \n\ndef encryptUsingIndex(plaintext: str, key: int) -&gt; str: \n    '''\n    constraints\n    -----------\n    key &gt;= 0 and \n    key &lt; 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000\n    '''\n    actual_key = getKeyFromIndex(z = key)\n    return ex1_3.encrypt(plaintext=plaintext, key=actual_key)\n\ndef decryptUsingIndex(ciphertext: str, key: int) -&gt; str: \n    '''\n    constraints\n    -----------\n    key &gt;= 0 and \n    key &lt; 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000\n    '''\n    actual_key = getKeyFromIndex(z = key)\n    return ex1_3.decrypt(ciphertext=ciphertext, key=actual_key)\nNote that when we pass the smallest key (i.e.¬†zero) to the function _getKeyFromIndex, we get alphabet as is:\n\nNote that when we pass the biggest key to the function _getKeyFromIndex, we get alphabet in reverse:\n\nencryptUsingIndex() and decryptUsingIndex() are straight forward except that you need to pass in an int as a key instead of a dict."
  },
  {
    "objectID": "Ch2_Hashing/2.5.html",
    "href": "Ch2_Hashing/2.5.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 2.5. THE POWER OF ONE\nWrite a program that does the following ten times (so, ten full loops with the time computed):\n\nRandomly select a single, lowercase letter. This is the ‚Äúpreimage seed.‚Äù\nUse MD5 to compute the hash of this initial letter. This is the ‚Äútest hash‚Äù.\nIn a loop, iterate through all possible lowercase one-letter inputs.\n\nHash each letter in the same way as before, and compare against the test hash.\nWhen you find a match, stop.\n\nCompute the amount of time it took to find a match.\n\nHow long, on average, did it take to find a match for a random preimage seed?\n\n\n# ex2_5.py \n\nimport hashlib\nimport secrets\nimport timeit\nfrom string import ascii_lowercase\n\ndef single_run(): \n\n    def h(x: str) -&gt; str:\n        '''returns the md5 digest of the string x.'''\n        return hashlib.md5(x.encode('utf-8')).hexdigest()\n\n    preimage_seed = secrets.choice(ascii_lowercase)\n    test_hash = h(preimage_seed)\n\n    for single_letter in ascii_lowercase: \n        if h(single_letter) == test_hash: \n            # found a match\n            break\n    return \n\nif __name__ == '__main__':\n    COUNTER = 10\n    total_execution_time = timeit.timeit(\n        stmt=\"single_run()\", \n        setup=\"from __main__ import single_run\", \n        number=COUNTER, \n    )\n    print(f\"Called single_run() {COUNTER} times. Total execution time (in seconds): {total_execution_time} sec\")\n    print(f\"Average execution time: {total_execution_time/COUNTER} sec\")\nWhen COUNTER is 10. \nWhen COUNTER is 1 million."
  },
  {
    "objectID": "Ch2_Hashing/2.7.html",
    "href": "Ch2_Hashing/2.7.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 2.7 PASSWORD LENGTH‚ÄôS EFFECTS ON ATTACK TIME\nRepeat the previous exercise, but this time for two-symbol inputs. Then try it with three and four symbols at a time. How much longer does it take to invert the randomly chosen input?\n\n\nSuppose the password is constructed from lowercase letters, uppercase letters, and numbers. Thus the python equivalent for this is string.ascii_letters + string.digits. This set contains \\(62\\) elements.\nThus,\n\n\n\nMaximum length of password\nNumber of total passwords\n\n\n\n\n\\(2\\)\n\\(62 + 62^2 = 3,906\\)\n\n\n\\(3\\)\n\\(62 + 62^2 + 62^3 = 242,234\\)\n\n\n\\(4\\)\n\\(62 + 62^2 + 62^3 + 62^4 = 15,018,570\\)\n\n\n\\(n\\)\n\\(\\frac{62}{61}(62^n-1)\\)\n\n\n\n\n# ex2_7.py \n\nimport hashlib\nimport secrets\nimport timeit\nfrom string import ascii_letters, digits\n\nALPHABET = ascii_letters + digits\n\ndef generate_random_password(max_length_of_password: int) -&gt; str:\n    length_of_password = 1 + secrets.randbelow(max_length_of_password) \n    return ''.join(secrets.choice(ALPHABET) for _ in range(length_of_password))\n\ndef h(x: str) -&gt; str:\n    '''returns the md5 digest of the string x.'''\n    return hashlib.md5(x.encode('utf-8')).hexdigest()\n\ndef single_run(digest_of_password: str, max_length_of_password: int): \n    def generate(alphabet, max_len):\n        if max_len &lt;= 0: return\n        for c in alphabet:\n            yield c\n        for c in alphabet:\n            for next in generate(alphabet, max_len-1):\n                yield c + next\n\n    for possible_password in generate(alphabet=ALPHABET, max_len=max_length_of_password): \n        if h(possible_password) == digest_of_password: \n            # found a match\n            break\n    return \n\nif __name__ == '__main__':\n    COUNTER = 1\n\n    for length_of_password in range(2,5):\n        rand_pass = generate_random_password(max_length_of_password=length_of_password)\n        h_rand_pass = h(rand_pass) \n        total_execution_time = timeit.timeit(\n            stmt=f\"single_run('{h_rand_pass}', {length_of_password})\", \n            setup=\"from __main__ import single_run\", \n            number=COUNTER, \n        )\n        print(f\"Called single_run('{h_rand_pass}', {length_of_password}) {COUNTER} time(s). Total execution time (in seconds): {total_execution_time} sec\")\n        print(f\"Average execution time: {total_execution_time/COUNTER} sec\")\n        print(f\"password was: {rand_pass}\")\n        print(\"\\n--------------------------------\\n\")\n\nHow about the worst case scenario??\nNote that\n&gt;&gt;&gt; import ex2_7\n&gt;&gt;&gt; ex2_7.ALPHABET\n'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n&gt;&gt;&gt; \nThus:"
  },
  {
    "objectID": "Ch2_Hashing/2.8.html",
    "href": "Ch2_Hashing/2.8.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 2.8 MORE HASH, MORE TIME\nChoosing a complex-to-invert password is the responsibility of the user, but the systems storing the passwords can also slow down attackers by using a more complicated hashing function. Repeat any of the preceding exercies that use MD5, but now use SHA-1 and SHA-256 instead. Record how much longer it takes to get through the brute-force operations. Finally, try out bruteforce using scrypt. You might not get very far!\n\n\nI will use exercise 2.5 by changing the hash function from MD5 to SHA-1, SHA-256, and Scrypt.\n# ex2_8.py \n\nimport hashlib\nimport secrets\nimport timeit\nfrom string import ascii_lowercase\nfrom cryptography.hazmat.primitives.kdf.scrypt import Scrypt\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.exceptions import InvalidKey \n\ndef h_sha1(x: str) -&gt; str:\n    '''returns the sha1 digest of the string x.'''\n    return hashlib.sha1(x.encode('utf-8')).hexdigest()\n\ndef h_sha256(x: str) -&gt; str:\n    '''returns the sha256 digest of the string x.'''\n    return hashlib.sha256(x.encode('utf-8')).hexdigest()\n\ndef h_scrypt(x: str) -&gt; dict[str,bytes]:\n    '''returns the Scrypt digest of the string x.'''\n    salt = secrets.token_bytes(16)\n    kdf = Scrypt(salt=salt, length=32, n=2**14, r=8, p=1, backend=default_backend())\n    key = kdf.derive(x.encode('utf-8'))\n    return {\n        \"salt\": salt, \n        \"key\": key, \n    }\n\ndef h_scrypt_verify(x: str, salt: bytes, key: bytes):\n    kdf = Scrypt(salt=salt, length=32, n=2**14, r=8, p=1, backend=default_backend())\n    kdf.verify(x.encode('utf-8'), key)\n\nhashing_functions = {\n    \"sha1\": h_sha1, \n    \"sha256\": h_sha256, \n    \"scrypt\": h_scrypt, \n}\n\ndef single_run(hashing_function_name: str):\n    h = hashing_functions[hashing_function_name]\n\n    preimage_seed = secrets.choice(ascii_lowercase)\n    test_hash : dict[str,bytes] | str = h(preimage_seed)\n\n    for single_letter in ascii_lowercase: \n        if hashing_function_name in ['sha1', 'sha256']:\n            if h(single_letter) == test_hash: \n                # found a match\n                break\n        elif hashing_function_name == \"scrypt\": \n            try:\n                # we know that test_hash is a dict[str, bytes].\n                h_scrypt_verify(single_letter, **test_hash)\n                break\n            except InvalidKey:\n                pass \n    else:\n        # Executes when the above loop terminates through exhaustion of the iterable. \n        # But not when the loop is terminated by a break statement. \n        raise AssertionError(\"the above loop should always break out!!\")    \n    return \n\nif __name__ == '__main__':\n    COUNTER = 10\n    for hashing_function_name in hashing_functions.keys():\n        total_execution_time = timeit.timeit(\n            stmt=f\"single_run('{hashing_function_name}')\", \n            setup=\"from __main__ import single_run\", \n            number=COUNTER, \n        )\n        print(f\"Called single_run('{hashing_function_name}') {COUNTER} times. Total execution time (in seconds): {total_execution_time} sec\")\n        print(f\"Average execution time: {total_execution_time/COUNTER} sec\")\n        print(\"\\n--------------------------------\\n\")\nWhen COUNTER \\(= 10\\):\n\nWhen COUNTER \\(= 30\\):"
  },
  {
    "objectID": "Ch2_Hashing/2.3.html",
    "href": "Ch2_Hashing/2.3.html",
    "title": "Practical Cryptography In Python",
    "section": "",
    "text": "Observing Avalanche\nCompare the bit changes between a wide range of input values.\n\n\nThe following function observe_avalanche(x1, x2) is used to count the bit changes or differences between \\(\\text{md5}(x_1)\\) and \\(\\text{md5}(x_2)\\):\n# assume this code is stored inside of a file called: ex2_3.py\n\nimport hashlib\n\nh = lambda x : hashlib.md5(x).hexdigest()\n\ndef observe_avalanche(x1: bytes, x2: bytes) -&gt; int: \n    y1 = h(x1)\n    y2 = h(x2)\n\n    change_to_binary = lambda x : bin(int(x,16))[2:]\n\n    b_y1 = change_to_binary(y1)\n    b_y2 = change_to_binary(y2)\n\n    if len(b_y1) != 128: \n        b_y1 = ('0' * (128 - len(b_y1))) + b_y1\n\n    if len(b_y2) != 128: \n        b_y2 = ('0' * (128 - len(b_y2))) + b_y2\n    \n    # counter is the number of bits that are different in \n    # digests of x1 and x2. \n    counter = 0\n    for x, y in zip(b_y1, b_y2): \n        if x != y: \n            counter += 1 \n    return counter\nThe following shows the usage of the above function:"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.10.html",
    "href": "Ch4_Asymmetric_Encryption/4.10.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.10: COMMON MODULUS USE CASES\nWrite out an additional scenario when the use of the common modulus attack might be useful to an attacker.\n\n\nSuppose Bob is a software developer. He has a software called XYZ. Suppose also XYZ is a cross platform software that runs on Windows and Android.\nThe backend of XYZ is at http://example.com.\nSuppose that Bob has 2 pairs of RSA keys (private-key-1, public-key-1) and (private-key-2, public-key-2) stored on his server.\nSuppose that public-key-1 is baked into the code of the XYZ software Windows version, and public-key-2 is baked into the code of the XYZ software Android version.\nSuppose also that public-key-1 and public-key-2 have the same modulus but different encryption exponents.\nSuppose that Alice is a user of software XYZ and has installed the software on her PC and phone. Suppose now Alice sends the same message (using HTTP POST method) to Bob on both her PC and phone and Eve intercepts both ciphertext messages.\nEve can then perform the Common Modulus Attack."
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.16.html",
    "href": "Ch4_Asymmetric_Encryption/4.16.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.16: ROCA VULNERABLE KEYS\nUnless your RSA keys are being generated by certain RSA hardware modules, the keys you have generated for the exercises in this chapter should not be vulnerable to ROCA, but it never hurts to check. For this exercise, visit the online ROCA vulnerability checking site at https://keychest.next/roca#/ and test a couple of keys.\n\n\nThe ROCA vulnerability is a cryptographic weakness that allows the private key of a key pair to be recovered from the public key in keys generated by devices with the vulnerability. ‚ÄúROCA‚Äù is an acronym for ‚ÄúReturn of Coppersmith‚Äôs attack‚Äù.\nMore can be found in the wiki page: https://en.wikipedia.org/wiki/ROCA_vulnerability"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.4.html",
    "href": "Ch4_Asymmetric_Encryption/4.4.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.4: BRUTE-FORCE RSA\nWrite a program that uses brute force to decrypt an RSA-encrypted word that is all lowercase (no spaces) and has length less than or equal to 4. The program should take a public key and the RSA-encrypted ciphertext as the inputs. Use the RSA encryption program to generate a few words of four or fewer letters and break these codes with your brute-force program.\n\n\nThis exercise is very similar to Exercise 2.7.\nSince the password is constructed from lowercase letters, the python equivalent for this is string.ascii_lowercase. The length of this sequence is \\(26\\).\nQuestion: How many possible plaintexts are there?\nAnswer: \\(26 + 26^2 + 26^3 + 26^4 = 475,254\\)\n# ex4_4.py\nimport string\nimport gmpy2,os, binascii\nfrom cryptography.hazmat.backends import default_backend \nfrom cryptography.hazmat.primitives.asymmetric.types import PublicKeyTypes \nfrom cryptography.hazmat.primitives import serialization \n\n# This module is defined in the solution of Exercise 4.1\nimport listing4_4\n\nMAX_LEN_OF_PLAINTEXT = 4\n\n# taken from solution of Exercise 2.7\ndef generate(alphabet, max_len):\n    if max_len &lt;= 0: return\n    for c in alphabet:\n        yield c\n    for c in alphabet:\n        for next in generate(alphabet, max_len-1):\n            yield c + next\n\ndef rsa_encrypt(pk, m: str): \n    '''\n    pk: is the public key. \n    m: is the message in strings.\n    '''\n    m = m.encode() \n    m = listing4_4.bytes_to_int(m)\n\n    # c is the ciphertext in integer \n    c = listing4_4.simple_rsa_encrypt(m = m, public_key=pk)\n\n    # change c into bytes. \n    c = listing4_4.int_to_bytes(c)\n\n    # hexlify c and return it.\n    return c.hex()\n\ndef main(public_key: PublicKeyTypes, ciphertext: str): \n    for possible_plaintext in generate(alphabet=string.ascii_lowercase, max_len=MAX_LEN_OF_PLAINTEXT): \n        if rsa_encrypt(pk=public_key, m=possible_plaintext) == ciphertext: \n            # we have successfully found a pre image. \n            print(f\"Plaintext: {possible_plaintext}\")\n            break\n    else: \n        print(\"No preimage found.\")\n\n\nif __name__ == '__main__': \n    public_key_file = input(\"Enter the public key file&gt; \") \n    public_key = None \n\n    if not os.path.exists(public_key_file):\n        print(\"File does not exist.\")\n        exit(-1)\n    \n    with open(public_key_file, 'rb') as f: \n        public_key = serialization.load_pem_public_key(\n            data=f.read(),\n            backend=default_backend()\n        )\n        print(\"\\nPublic Key file loaded.\\n\")\n\n    ciphertext = input(\"Enter the ciphertext&gt; \") \n    main(public_key=public_key, ciphertext=ciphertext) \nSuppose the code above is inside of a file called ex4_4.py.\nThis is what the working directory for this exercise should look like: \nNotice that we are using the code given in the solution of Exercise 4.1 (listing4_4.py).\nThe file public_key.txt contains the following:\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAk+NWmBeMjnY7KXgdIm2C\nXcAS9h9ekBFchu2B1MHrrMPHmxQKQr/cGQs5tc8Qg6pWpSKRgmmBA42vgOTnE+CL\nuPvK187DEbDN8FfMWCQfUuvsE+u8mHwPS067IoL8sROY1SPhS6Pru2uhwLoPVNmI\nCKVwqHb5j6ByuZRjlGN/ws1xDzscdOmjoIGVVy+yw9KA2P6ynarxATUqeUWiZdCZ\n3bnZ/xHBlZlRodKc0F0nOVkuLKduO91tHP5Dqdch6vmHsFb79L0YI62BYIcwR7QV\nF8vIlOU0MDHYnASkgO8xQ1wO21zTWRmZrNGfGYtZ6xJ7XnTW7UUYxBNYM43wFQNN\nmQIDAQAB\n-----END PUBLIC KEY-----\nNow, that we know what is contained in every file, let‚Äôs run ex4_4.py:"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.15.html",
    "href": "Ch4_Asymmetric_Encryption/4.15.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.15: FACTORING RSA KEYS\nIn this section, we recommended using 2048-bit keys. For this exercise, do an Internet search to find out the current size of keys that can easily be factored. For example, do a search for ‚Äúfactoring as a service‚Äù and see how much it costs to factor a 512-bit key.\n\n\n512-bit integers can be factored in 4 hours for less than $100 of compute time in a public cloud environment.\nMore can be found here: https://github.com/eniac/faas\nAnd for the paper Factoring as a service"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.9.html",
    "href": "Ch4_Asymmetric_Encryption/4.9.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.9: COMMON MODULUS ATTACK\nTest out the code in this section by creating a common modulus attack demo.\n\n\nSuppose the following code is inside of a file called ex4.9.py.\nAlso note that, listing4_4.py is the code given in Listing 4.4 of the book.\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import rsa \nimport listing4_4 as l \n\ndef bezouts_theorem(a: int, b: int) -&gt; (int, int): \n    '''\n    Let a and b be positive integers. Then the equation \n        a*u + b*v = gcd(a,b) [Bezout's Theorem]\n    always has a solution in integers u and v. \n\n    This function simply returns those integers (u,v) as  a tuple. \n    '''\n    class BezoutNumber: \n        def __init__(self, num: int, coeff_of_a: int, coeff_of_b: int):\n            self.num = num\n            self.u = coeff_of_a # u is a coefficient of a.\n            self.v = coeff_of_b # v is a coefficient of b. \n            assert(self.u * a + self.v * b == self.num) \n        \n        def __lt__(self, x): \n            assert(isinstance(x, BezoutNumber))\n            return self.num &lt; x.num \n        \n        def __mod__(self, rhs): \n            assert(isinstance(rhs, BezoutNumber))\n            # print(\"self: \", self, \"\\trhs: \", rhs)\n            u_i = self.u \n            v_i = self.v \n            u_ip1 = rhs.u # u_{i+1}\n            v_ip1 = rhs.v\n            q_ip1 = self.num // rhs.num\n\n            return BezoutNumber(\n                num=self.num % rhs.num,\n                coeff_of_a=u_i - u_ip1 * q_ip1,\n                coeff_of_b=v_i - v_ip1 * q_ip1,\n            )\n\n        def __str__(self): \n            return f\"{self.u} * {a} + {self.v} * {b} = {self.num}\"\n\n    def bezout_gcd(a: BezoutNumber,b: BezoutNumber)-&gt;BezoutNumber:\n        '''\n        impelements the euclidean algorithm for finding\n        gcd: greatest common divisor\n        '''\n        while True:\n            if a &lt; b: \n                a,b = b,a\n            if b.num == 0:\n                return a \n            a,b = b,a%b\n    \n    result = bezout_gcd(\n        a = BezoutNumber(num=a, coeff_of_a=1, coeff_of_b=0), \n        b = BezoutNumber(num=b, coeff_of_a=0, coeff_of_b=1),\n    )\n    return (result.u, result.v)\n\ndef common_modulus_decrypt(c1, c2, key1, key2): \n    key1_numbers = key1.public_numbers() \n    key2_numbers = key2.public_numbers() \n\n    if key1_numbers.n != key2_numbers.n: \n        raise ValueError(\"Common modulus attack requires a common modulus\") \n    n = key1_numbers.n \n\n    if key1_numbers.e == key2_numbers.e: \n        raise ValueError(\"Common modulus attack requires different public exponents\") \n    \n    e1, e2 = key1_numbers.e, key2_numbers.e \n\n    a, b = bezouts_theorem(e1, e2) \n    mx = pow(c1, a, n) \n    my = pow(c2, b, n) \n    # Note that, although not stated explicitly we are assuming that \n    # the gcd(e1, e2) = 1. \n    return mx * my % n  \n\nif __name__ == '__main__': \n    private_key1 = rsa.generate_private_key(\n        public_exponent=65537, \n        key_size=2048, \n        backend=default_backend(), \n    )\n    public_key1 = private_key1.public_key() \n\n    n = public_key1.public_numbers().n \n    public_key2 = rsa.RSAPublicNumbers(3, n).public_key(default_backend())\n\n    message = b\"hello world how are you doing?\"\n    message = l.bytes_to_int(message) \n\n    c1 = l.simple_rsa_encrypt(message, public_key1)\n    c2 = l.simple_rsa_encrypt(message, public_key2) \n\n    print(\"Original Message: \", l.int_to_bytes(message))\n    print(\"Message Hacked by Eve: \", l.int_to_bytes(\n        common_modulus_decrypt(\n            c1=c1, \n            c2=c2, \n            key1=public_key1, \n            key2=public_key2, \n        )\n    ))\nExecution:"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.3.html",
    "href": "Ch4_Asymmetric_Encryption/4.3.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.3: WHAT‚ÄôS THE ANSWER TO LIFE, THE UNIVERSE, AND EVERYTHING?\nWe have already talked about chosen plaintext attacks in the previous chapter. The same attack can be used here. Again assume the role of Eve, the WACKO agent. You‚Äôve intercepted Bob‚Äôs public key in the newspaper, and you have access to the RSA encryption program. If you suspect you know what Alice is sending in her encrypted messages, explain or demonstrate how you would verify your guesses.\n\n\nIf Eve has a guess of what Alice is sending to Bob, all she needs to do is encrypt her guess by using the Bob‚Äôs public key and the RSA encryption program. Then she compares the ciphertext that she generated with what came from Alice. If they are the same, then that means her guess was correct. Otherwise, incorrect."
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.13.html",
    "href": "Ch4_Asymmetric_Encryption/4.13.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.13: TAKING THE TIME\nHow long does the attack take? Instrument your code with timing checks and a count of how many times the oracle function is called. Run the attack on a suite of inputs and determine the average amount of time to break keys of size $512, 1024, $ and \\(2048\\).\n\n\n\nThe code:\n# ex4.13.py\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey, RSAPublicKey\nfrom cryptography.hazmat.primitives import hashes,serialization \nfrom cryptography.hazmat.backends import default_backend \nimport gmpy2 \n\nfrom collections import namedtuple \nimport timeit\n\nInterval = namedtuple('Interval', ['a', 'b']) \n\ndef simple_rsa_encrypt(m, public_key): \n    numbers = public_key.public_numbers() \n    return gmpy2.powmod(m, numbers.e, numbers.n)\n\ndef simple_rsa_decrypt(c: int, private_key): \n    numbers = private_key.private_numbers() \n    return gmpy2.powmod(c, numbers.d, numbers.public_numbers.n)\n\ndef int_to_bytes(i, min_size=None):\n    # i might be a gmpy2 big integer; convert back to a Python int. \n    i = int(i) \n    b = i.to_bytes((i.bit_length()+7)//8, byteorder='big')\n    if min_size != None and len(b) &lt; min_size: \n        b = b'\\x00'*(min_size - len(b)) + b \n    return b \n\ndef bytes_to_int(b): \n    return int.from_bytes(b, byteorder='big')\n\nclass Oracle: \n    pass \n\nclass FakeOracle(Oracle): \n    def __init__(self, private_key): \n        self.private_key = private_key \n        self.counter = 0\n    \n    def __call__(self,cipher_text:int)-&gt; bool : \n        self.counter += 1 \n        recovered_as_int = simple_rsa_decrypt(cipher_text, private_key=self.private_key)\n        recovered = int_to_bytes(recovered_as_int, min_size=self.private_key.key_size//8) \n        return recovered[:2] == bytes([0, 2])\n    \n\nclass RSAOracleAttacker: \n    def __init__(self, public_key: RSAPublicKey, oracle: Oracle): \n        self.public_key = public_key \n        self.oracle = oracle \n    \n    def _step1_blinding(self, c): \n        self.c0 = c \n        \n        self.B = 2 ** (self.public_key.key_size - 16)\n        self.s = [1] \n        self.M = [ \n            [Interval(2 * self.B, 3 * self.B - 1)],\n        ]\n\n        self.i = 1 \n        self.n = self.public_key.public_numbers().n \n    \n    def _find_s(self, start_s, s_max = None): \n        si = start_s \n        ci = simple_rsa_encrypt(si, self.public_key) \n\n        while not self.oracle((self.c0 * ci) % self.n):\n            si += 1 \n\n            if s_max and (si &gt; s_max): \n                return None \n            \n            ci = simple_rsa_encrypt(si, self.public_key) \n\n        return si \n    \n    def _step2a_start_the_searching(self): \n        si = self._find_s(start_s=gmpy2.c_div(self.n, 3 * self.B))\n        return si \n    \n    def _step2b_searching_with_more_than_one_interval(self): \n        si = self._find_s(start_s=self.s[-1] + 1) \n        return si \n    \n    def _step2c_searching_with_one_interval_left(self): \n        a, b = self.M[-1][0]\n        ri = gmpy2.c_div(2*(b*self.s[-1] - 2 * self.B), self.n) \n        si = None \n\n        while si == None: \n            si = gmpy2.c_div((2*self.B + ri * self.n), b) \n            s_max = gmpy2.c_div((3 * self.B + ri * self.n), a) \n            si = self._find_s(start_s = si, s_max = s_max) \n            ri += 1 \n        \n        return si \n    \n    def _step3_narrowing_set_of_solutions(self, si): \n        new_intervals = set() \n        for a, b in self.M[-1]: \n            r_min = gmpy2.c_div((a*si - 3 * self.B + 1), self.n) \n            r_max = gmpy2.f_div((b*si - 2 * self.B), self.n) \n\n            for r in range(r_min, r_max + 1): \n                a_candidate = gmpy2.c_div((2 * self.B + r * self.n), si) \n                b_candidate = gmpy2.f_div((3 * self.B-1 + r * self.n), si) \n\n                new_interval = Interval(max(a, a_candidate), min(b, b_candidate)) \n\n                new_intervals.add(new_interval) \n        \n        new_intervals = list(new_intervals) \n        self.M.append(new_intervals) \n        self.s.append(si) \n\n        if len(new_intervals) == 1 and new_intervals[0].a == new_intervals[0].b: \n            return True \n    \n        return False \n\n    def _step4_computing_the_solution(self): \n        interval = self.M[-1][0] \n        return interval.a \n    \n    def attack(self, c): \n        self._step1_blinding(c) \n\n        # do this until there is one interval left \n        finished = False \n        while not finished: \n            if self.i == 1: \n                si = self._step2a_start_the_searching()\n            elif len(self.M[-1]) &gt; 1: \n                si = self._step2b_searching_with_more_than_one_interval() \n            elif len(self.M[-1]) == 1: \n                interval = self.M[-1][0]\n                si = self._step2c_searching_with_one_interval_left() \n            \n            finished = self._step3_narrowing_set_of_solutions(si) \n            self.i += 1 \n        \n        m = self._step4_computing_the_solution() \n        return m  \n\n\nif __name__ == '__main__': \n    key_sizes_to_try = [512, 1024, 2048]\n\n    private_keys: list[RSAPrivateKey] = [\n        rsa.generate_private_key(\n            public_exponent=65537, \n            key_size=key_size, \n            backend=default_backend(),\n        )\n        for key_size in key_sizes_to_try\n    ]\n    print(\"[+] Three private keys generated successfully.\")\n\n    public_keys: list[RSAPublicKey] = [\n        single_private_key.public_key()\n        for single_private_key in private_keys\n    ]\n    print(\"[+] Corresponding public keys generated successfully.\")\n\n\n    oracles: list[FakeOracle] = [\n        FakeOracle(private_key=single_private_key)\n        for single_private_key in private_keys\n    ]\n    print(\"[+] Corresponding Oracles generated successfully.\")\n\n\n    msg = b'Hello Bob? How are you? Max varies. Love Alice'\n\n    ciphertexts = [\n        public_key.encrypt(\n            plaintext = msg, \n            padding = padding.PKCS1v15(),\n        )\n        for public_key in public_keys\n    ]\n\n    rsa_oracle_attackers: list[RSAOracleAttacker] = [\n        RSAOracleAttacker(public_key=public_key, oracle=oracle)\n        for public_key, oracle in zip(public_keys, oracles)\n    ]\n    print(\"[+] Corresponding Oracle attackers generated successfully.\")\n\n\n    print(\"Setup code done. Attack phase starting...\")\n    for key_size, attacker, c in zip(key_sizes_to_try, rsa_oracle_attackers, ciphertexts): \n        print(f\"Attacking the ciphertext encrypted with key size: {key_size}\")\n        \n        c_in_int: int = bytes_to_int(c)\n        \n        time_it_took = timeit.timeit(lambda: attacker.attack(c_in_int), number=1)\n        print(f\"\\t * Time it took: {time_it_took} seconds\")\n        print(f\"\\t * Number of times oracle is called: {attacker.oracle.counter}\")\nNote that this code does not answer the question fully. The question asks to give the code a ‚Äúsuite of inputs‚Äù and to take the average. I will leave that up to you. üòâ"
  },
  {
    "objectID": "Ch4_Asymmetric_Encryption/4.11.html",
    "href": "Ch4_Asymmetric_Encryption/4.11.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 4.11: GETTING AN UPGRADE\nHelp Alice and Bob out. Rewrite the RSA encryption/decryption program to use the cryptography module instead of gmpy2 operations.\n\n\n# ex4_11.py (way more secure than listing4_4.py)\nimport os\nfrom cryptography.hazmat.backends import default_backend \nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization \nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.asymmetric import padding\n\ndef rsa_encrypt(m: bytes, public_key: rsa.RSAPublicKey): \n    return public_key.encrypt(\n        plaintext=m, \n        padding=padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()), \n            algorithm=hashes.SHA256(), \n            label=None,\n        ),\n    )\n\ndef rsa_decrypt(c: bytes, private_key: rsa.RSAPrivateKey): \n    return private_key.decrypt(\n        ciphertext=c, \n        padding=padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()), \n            algorithm=hashes.SHA256(), \n            label=None,\n        ),\n    )\n\ndef main(): \n    public_key_file = None \n    private_key_file = None \n    public_key = None \n    private_key = None \n\n    while True: \n        print(\"RSA Crypto\") \n        print(\"------------------\")\n        print(\"\\tPrivate key file: {}\".format(private_key_file))\n        print(\"\\tPublic key file: {}\".format(public_key_file)) \n        print(\"\\t1. Encrypt Message\")\n        print(\"\\t2. Decrypt Message.\")\n        print(\"\\t3. Load public key file \")\n        print(\"\\t4. Load private key file.\") \n        print(\"\\t5. Create and load new public and private key files.\")\n        print(\"\\t6. Quit.\\n\")\n\n        choice = input(\"&gt;&gt; \") \n\n        if choice == \"1\": \n            if not public_key: \n                print(\"\\nNo public key loaded\\n\") \n            else: \n                message = input(\"\\nPlaintext: \").encode() \n                ciphertext = rsa_encrypt(message, public_key) \n                print(\"\\nCiphertext (hexlified): {}\\n\".format(ciphertext.hex()))\n        elif choice == '2':\n            if not private_key: \n                print(\"\\nNo private key loaded\\n\")\n            else: \n                ciphertext_hex = input(\"\\nCiphertext (hexlified): \") \n                ciphertext = bytes.fromhex(ciphertext_hex)\n                message = rsa_decrypt(ciphertext, private_key)\n                print(\"\\nPlaintext: {}\\n\".format(message)) \n        elif choice == '3': \n            public_key_temp_file = input(\"\\nEnter public key file: \")\n            if not os.path.exists(public_key_temp_file): \n                print(f\"File {public_key_temp_file} does not exist.\")\n                continue \n            with open(public_key_temp_file, 'rb') as f: \n                public_key = serialization.load_pem_public_key(\n                    data=f.read(),\n                    backend=default_backend()\n                )\n                public_key_file = public_key_temp_file\n                print(\"\\nPublic Key file loaded.\\n\")\n\n                # unload private key if any\n                private_key_file = None \n                private_key = None \n        elif choice == '4':\n            private_key_file_temp = input(\"\\nEnter private key file: \")\n            if not os.path.exists(private_key_file_temp):\n                print(f\"File {private_key_file_temp} does not exist.\")\n                continue \n            with open(private_key_file_temp, 'rb') as f: \n                private_key = serialization.load_pem_private_key(\n                    data=f.read(),\n                    backend=default_backend(),\n                    password=None\n                ) \n                private_key_file = private_key_file_temp \n                print(\"\\nPrivate Key file loaded.\\n\") \n\n                # load public key for the given private key \n                # (unload previous public key if any) \n                public_key = private_key.public_key() \n                public_key_file = None \n        elif choice == '5': \n            private_key_file_temp = input(\"\\nEnter a file name for new private key: \") \n            public_key_file_temp = input(\"\\nEnter a file name for a new public key: \") \n            \n            if os.path.exists(private_key_file_temp) or os.path.exists(public_key_file_temp): \n                print(\"File already exists\") \n                continue\n\n            with open(private_key_file_temp, \"wb+\") as private_key_file_obj: \n                with open(public_key_file_temp, \"wb+\") as public_key_file_obj: \n                    private_key = rsa.generate_private_key(\n                        public_exponent=65537, \n                        key_size=2048, \n                        backend=default_backend(),\n                    )\n                    public_key = private_key.public_key() \n\n                    private_key_file_obj.write(\n                        private_key.private_bytes(\n                            encoding=serialization.Encoding.PEM, \n                            format=serialization.PrivateFormat.TraditionalOpenSSL, \n                            encryption_algorithm=serialization.NoEncryption(), \n                        )\n                    )\n\n                    public_key_file_obj.write(\n                        public_key.public_bytes(\n                            encoding=serialization.Encoding.PEM, \n                            format=serialization.PublicFormat.SubjectPublicKeyInfo,\n                        )\n                    )\n\n                    public_key_file = None \n                    private_key_file = private_key_file_temp\n        elif choice == '6':\n            print(\"\\n\\nTerminating. This program will self destruct in 5 seconds. \\n\")\n            break\n        else: \n            print(\"\\n\\nUnknown Option {}.\\n\".format(choice))\n\nif __name__ == '__main__':\n    main() \nNote that the UI of the previous code is identical to the UI of the code given in Exercise 4.1. Thus the following video still is correct for the above code.\n\n\n\nHere is a 2 minute youtube video explaining it all."
  },
  {
    "objectID": "Ch5_Message_Integrity_Signatures_and_Certificates/5.2.html",
    "href": "Ch5_Message_Integrity_Signatures_and_Certificates/5.2.html",
    "title": "Alice‚Äôs Session",
    "section": "",
    "text": "EXERCISE 5.2: EVER EVIL EVE\nGo ahead and ‚Äúintercept‚Äù some of the messages encrypted by the code you wrote in this section. Modify the intercepted messages and verify that your decryption mechanism correctly reports an error.\n\nAlice first creates her plaintext. Then she uses her newly generated key and nonce to encrypt her plaintext.\n\nimport ex5_1\nimport os \n\nplaintext = b\"Hi Bob, this is Alice!\"\nkey = os.urandom(32)\nnonce = os.urandom(16) \n\nencryptionManager = ex5_1.Encryptor(key=key, nonce=nonce)\nciphertext = encryptionManager.update_encryptor(plaintext=plaintext)\nciphertext += encryptionManager.finalize_encryptor()"
  },
  {
    "objectID": "Ch5_Message_Integrity_Signatures_and_Certificates/5.3.html",
    "href": "Ch5_Message_Integrity_Signatures_and_Certificates/5.3.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 5.3: BRUTE FORCE AGAIN\nYou should already have done some brute-force attacks in previous chapters, but it‚Äôs important to repeat the exercise until you develop intuition for the concept. Using our preceding fake HMAC, have the computer generate a random password of specific sizes and use brute-force methods to find out what it is. To be more specific, assume that you already know what the message is (e.g.¬†‚Äúhello world‚Äù, ‚Äúhappy birthday‚Äù, or a message of your choosing). Write a program to create a random password of characters, prepend the password to the message, and then print out the MAC (hash). Take the output and iterate through all possible passwords until you find the right one. Start with a simple test of a single-letter character, then try two characters, and so forth. Mix things up by using different sets of characters such as all lowercase, lowercase and uppercase, either case plus numbers, and so forth.\n\n\n# code goes here.\nimport secrets \nimport hashlib \nfrom string import ascii_letters, digits\n\ndef generate(n: int) -&gt; str:\n    return ''.join(\n        [\n            secrets.choice(ALPHABET)\n            for _ in range(n)\n        ]\n    )\n\ndef get_the_mac(n: int = 2) -&gt; str: \n    hasher = hashlib.sha256() \n    hasher.update(generate(n).encode() + b\"Happy Birthday\") \n    return hasher.hexdigest()\n\ndef bruteforce()"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.21.html",
    "href": "Ch3_Symmetric_Encryption/3.21.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.21: PREDICTING TIME-BASED RANDOMNESS\nWrite an AES encryption program (or modify one of the others you‚Äôve written for this chapter) that uses Python random number generator to generate keys. Use the seed method to explicitly configure the generator based on the current time using time.time() rounded to the nearest second. Then use this generator to create a key and encrypt some data. Write a separate program that takes the encrypted data as input and tries to guess the key. It should take a minimum time and a maximum time as a range and try iterating between these two points as seed values for random.\n\n\n# ex3_21.py \n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import padding\nimport os\nimport random\nimport time \n\ndef encrypt_msg(msg: bytes) -&gt; dict: \n    current_time = round(time.time()) # rounded to the nearest second\n    r = random.Random(current_time)\n\n    key = r.getrandbits(128).to_bytes(16, 'big')\n    iv  = r.getrandbits(128).to_bytes(16, 'big')\n    \n    aesCipher = Cipher(\n        algorithm=algorithms.AES(key=key),\n        mode=modes.CTR(nonce=iv),\n        backend=default_backend(),\n    )\n    encryptor = aesCipher.encryptor() \n    return {\n        \"msg\": msg, \n        \"encrypted-msg\": encryptor.update(msg) + encryptor.finalize(), \n        \"key\": key, \n        \"iv\": iv, \n        \"current_time\": current_time, \n    }\n\ndef hack_encrypted_msg(encrypted_msg: bytes, min_time: int, max_time: int, msg: bytes): \n    for possible_seed in range(min_time, max_time + 1): \n        r = random.Random(possible_seed)\n        possible_key = r.getrandbits(128).to_bytes(16, 'big')\n        possible_iv = r.getrandbits(128).to_bytes(16, 'big')\n\n        aesCipher = Cipher(\n            algorithm=algorithms.AES(key=possible_key),\n            mode=modes.CTR(nonce=possible_iv),\n            backend=default_backend(),\n        )\n        decryptor = aesCipher.decryptor() \n        possible_msg = decryptor.update(encrypted_msg)\n        possible_msg += decryptor.finalize() \n\n        if (possible_msg == msg): \n            # we have a hit. \n            return possible_key \n\nif __name__ == '__main__': \n    msg = b'hello world how are you doing'\n    result = encrypt_msg(\n        msg=msg,\n    )\n    print(\"Hacked Key: \", hack_encrypted_msg(\n        encrypted_msg=result['encrypted-msg'], \n        min_time=result['current_time']-30,\n        max_time=result['current_time'] + 30, \n        msg=msg,\n    ))\n\n    print(\"Actual Key: \", result['key`'])\n\nMoral of the story: 1. Cryptographic keys should have enough randomness in them. Otherwise they are useless."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.7.html",
    "href": "Ch3_Symmetric_Encryption/3.7.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.7 SENDING BOB A FAKE MESSAGE\nTake two different ciphertexts from Alice to Bob with different meeting instructions on different dates. Splice the ciphertext from the body of the first message into the body of the second message. That is, start by replacing the last block of the newer message with the last block (or blocks if it was longer) of the previous message. Does the message decrypt? Did you change where Bob goes to meet Alice?\n\n\nThe following table is taken from the previous exercise (Exercise 3.6):\n\n\n\nNo\nCiphertext 1 Blocks\nCiphertext 2 Blocks\n\n\n\n\n1\ne5423e662cb98ca3ecf2c66b31cf1c8b\ne5423e662cb98ca3ecf2c66b31cf1c8b\n\n\n2\nf7c240c61a9c1453aae2edb028fa8459\nf7c240c61a9c1453aae2edb028fa8459\n\n\n3\n3d6ec4443f76ebc5a8abb94879113e58\n3d6ec4443f76ebc5a8abb94879113e58\n\n\n4\n88191d257c5970af6774a9f696681766\n88191d257c5970af6774a9f696681766\n\n\n5\n9473f734c616d05dae998037a11f67ab\na9f7e4995ec96761b811c24953c19907\n\n\n6\nee0c3ea2b40c09d80e9558cacf1a60ef\nf70cc1a151a388f34c59b7b83ae0fb08\n\n\n7\n66651c2dc32f4c25f276968d8efda22d\n4d91ea64099f6cb3dea4d1c0edcab02f\n\n\n8\n[empty]\n5a31ed03bf733b150ca46118d8fd8e95\n\n\n\nI took the first \\(5\\) blocks of the second ciphertext and the \\(6\\) th and \\(7\\) th block of the first ciphertext to create an evil ciphertext as shown below:\n\nThe original message from Alice to Bob on the 2nd of January was to meet at ‚Äútown square‚Äù at ‚Äú1130‚Äù. Thus Bob is going to try to meet Alice at the wrong place and wrong time on January 2, 2001.\nMoral of the story: Don‚Äôt use AES-ECB in production!!!"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.4.html",
    "href": "Ch3_Symmetric_Encryption/3.4.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.4: OTHER CIPHERS\nDo a little research about RC4 and Twofish. Where are they used? What kinds of problems does RC4 have? What are some of Twofish‚Äôs advantages over AES?\n\n\nLittle note on RC4: It is a stream cipher. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure. Read more here. RC4 was used in WEP, WPA, SSL, and even TLS until it was prohibited in 2015, by RFC 7465.\nLittle note on Twofish: Twofish is a symmetric key block cipher with a block size of \\(128\\) bits and key sizes up to \\(256\\) bits. Twofish‚Äôs distinctive features are the use of pre-computed key-dependent S-boxes, and a relatively complex key schedule."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.16.html",
    "href": "Ch3_Symmetric_Encryption/3.16.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.16: SIFTING THROUGH XOR\nXOR together some plaintext messages and look around for patterns and readable data. There‚Äôs no need to use any encryption for this, just take some regular, human-readable messages and XOR the bytes. Try human-readable strings, XML, JSON, and other formats. You may not find a lot that is instantly decipherable, but it‚Äôs a fun exercise.\n\n\nThe following picture shows XORing two plaintext messages:\n\nIt is very hard for the attacker to get msg1 and msg2 from the XOR. For example, the first byte of msg1 is h and the first byte of msg2 is b. XOR of their ASCII values gives 10. If you try to XOR every pair of lowercase letters (\\(26 \\times 26 = 676\\) pairs) and check if they give a value of 10, you will find 20 possibilities. They are:\n\nBottom line, don‚Äôt reuse key/IV pair."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.17.html",
    "href": "Ch3_Symmetric_Encryption/3.17.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.17: VISUALIZING CIPHERTEXT CHANGES\nTo better understand the difference between counter mode and cipher block chaining mode, go back to the image encryption utility you wrote previously. Modify it to first encrypt and then decrypt the image, using either AES-CBC or AES-CTR as the mode. After decryption, the original image should be completely restored.\nNow introduce an error into the ciphertext and decrypt the modified bytes. Try, for example, picking the byte right in the middle of the encrypted image data and setting it to 0. After corrupting the data, call the decryption function and view the restored image. How much of a difference did the edit make with CTR? How much of a difference did the edit make with CBC?\nHINT: If you can‚Äôt see anything, try an all-white image. If you still can‚Äôt see it, change 50 bytes or so to figure out where the changes are happening. Once you find where the changes are happening, go back to changing a single byte to view the differences between CTR and CBC. Can you explain what‚Äôs happening?\n\n\nRemember the following top-secret.bmp file from Exercise 3.11?\n\nThe following picture shows what we are going to do next.\n\nThe following code first encrypts top-secret.bmp, introduces an error and then decrypts the corrupted ciphertext.\n# ex3_17.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import padding \nimport os \n\nBLOCK_SIZE_OF_AES = 128 # bits\n\nkey = os.urandom(16) # we are using AES-128 \niv = os.urandom(16) \n\ndef encryptUsingCBCAndThenCorruptIt():\n    ifile = \"top-secret.bmp\" \n    ofile = \"top-secret-cbc-encrypted.bmp\"\n    with open(ifile, \"rb\") as reader: \n        with open(ofile, \"wb\") as writer: \n            image_data = reader.read() \n            header, body = image_data[:54], image_data[54:]\n            \n            # Pad the body\n            padder = padding.PKCS7(BLOCK_SIZE_OF_AES).padder()\n            body_padded = padder.update(body)\n            body_padded += padder.finalize()\n\n            # Encrypt the body\n            encryptor = Cipher(\n                algorithm=algorithms.AES(key),\n                mode=modes.CBC(iv),\n                backend=default_backend()\n            ).encryptor()\n            ciphertext = header + encryptor.update(body_padded)\n            ciphertext += encryptor.finalize() \n\n            # Corrupt the ciphertext\n            ciphertext = corruptCipherText(ciphertext=ciphertext)\n\n            # Write the ciphertext to disk. \n            writer.write(ciphertext)\n\ndef decryptUsingCBC(): \n    ifile = \"top-secret-cbc-encrypted.bmp\"\n    ofile = \"top-secret-cbc.bmp\"\n    with open(ifile, \"rb\") as reader: \n        with open(ofile, \"wb\") as writer: \n            image_data = reader.read() \n            header, body_encrypted = image_data[:54], image_data[54:]\n            \n            # Decrypt the body\n            decryptor = Cipher(\n                algorithm=algorithms.AES(key),\n                mode=modes.CBC(iv),\n                backend=default_backend()\n            ).decryptor()\n            body_padded = decryptor.update(body_encrypted)\n            body_padded += decryptor.finalize() \n\n            # Remove the padding bytes.\n            unpadder = padding.PKCS7(BLOCK_SIZE_OF_AES).unpadder()\n            body = unpadder.update(body_padded)\n            body += unpadder.finalize() \n\n            # Write the plaintext to disk. \n            writer.write(header + body)\n\ndef encryptUsingCTRAndThenCorruptIt():\n    ifile = \"top-secret.bmp\" \n    ofile = \"top-secret-ctr-encrypted.bmp\"\n    with open(ifile, \"rb\") as reader: \n        with open(ofile, \"wb\") as writer: \n            image_data = reader.read() \n            header, body = image_data[:54], image_data[54:]\n\n            # Encrypt the body\n            encryptor = Cipher(\n                algorithm=algorithms.AES(key),\n                mode=modes.CTR(iv),\n                backend=default_backend()\n            ).encryptor()\n            ciphertext = header + encryptor.update(body)\n            ciphertext += encryptor.finalize() \n\n            # Corrupt the ciphertext\n            ciphertext = corruptCipherText(ciphertext=ciphertext)\n\n            # Write the ciphertext to disk. \n            writer.write(ciphertext)\n\ndef decryptUsingCTR(): \n    ifile = \"top-secret-ctr-encrypted.bmp\"\n    ofile = \"top-secret-ctr.bmp\"\n    with open(ifile, \"rb\") as reader: \n        with open(ofile, \"wb\") as writer: \n            image_data = reader.read() \n            header, body = image_data[:54], image_data[54:]\n            \n            # Decrypt the body\n            decryptor = Cipher(\n                algorithm=algorithms.AES(key),\n                mode=modes.CTR(iv),\n                backend=default_backend()\n            ).decryptor()\n            plaintext = header + decryptor.update(body)\n            plaintext += decryptor.finalize() \n\n            # Write the plaintext to disk. \n            writer.write(plaintext)\n\n\ndef corruptCipherText(ciphertext: bytes)-&gt;bytes: \n    '''\n    This function changes the 54th byte of ciphertext to 0xff.\n    '''\n    k = 54 \n    ciphertext = ciphertext[:k] + b\"\\xff\" + ciphertext[k+1:]\n    return ciphertext\n\nif __name__ == '__main__': \n    # CBC operation\n    encryptUsingCBCAndThenCorruptIt()\n    decryptUsingCBC()\n\n    # CTR operation\n    encryptUsingCTRAndThenCorruptIt()\n    decryptUsingCTR()\nSo let‚Äôs run the above code:\n\ntop-secret-cbc.bmp and top-secret-ctr.bmp are shown below:\n \nIt is amazing how changing a single byte in the ciphertext, can have such dramatic color changes.\nNote that: when you rerun the above code (i.e.¬†ex3_17.py) you might get different effects since the key and iv are generated randomly on each run.\nMoral of the story: * Changing a single byte of a ciphertext that was encrypted with AES-CBC has the potential to change at most \\(17\\) bytes of the plaintext. (Why \\(17\\)? Think about it! üòâüòâ Hint: Block size of AES is \\(16\\))\n\nChanging a single byte of a ciphertext that was encrypted with AES-CTR has the potential to change at most \\(1\\) byte of the plaintext.\nAn enemy can fail to read a confidential message while still being able to change it in meaningful, deceptive ways."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.18.html",
    "href": "Ch3_Symmetric_Encryption/3.18.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.18: EMBRACING EVIL\nYou work for (or own!) Evil LLC. Time to steal some payments from Acme. Start with one of the encrypted payment messages you created in the earlier exercises. Calculate the size of the header up through the identification of the merchant and extract that many bytes of the encrypted data. XOR the plaintext header with the ciphertext header to get the keystream. Once you have this, XOR the extracted keystream with a header identifying Evil LLC as the merchant. This is the ‚Äúevil‚Äù ciphertext. Copy it over the bytes of the encrypted file to create a new payment message identifying your company as the recipient. Prove that it works by decrypting the modified file.\n\n\nBefore doing this question, I recommend that you do Exercise 3.15 they are very similar. In fact we are going to use the code given there as a library.\nFirst, find & define your original_header and calculate the length of the header. \nDefine your plaintext and ciphertext: \nXOR the plaintext header with the ciphertext header to get the keystream: \nOnce you have this, XOR the extracted keystream with a header identifying Evil LLC as the merchant. This is the ‚Äúevil‚Äù ciphertext. \nCopy the ‚Äúevil‚Äù header over the bytes of the encrypted file to create a new payment message identifying your company as the recipient. Prove that it works by decrypting the modified file."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.13.html",
    "href": "Ch3_Symmetric_Encryption/3.13.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.13: WRITE A SIMPLE COUNTER MODE\nAs you did with CBC, create counter mode encryption from ECB mode. This should be even easier that it was with CBC. Generate the key stream by taking the IV block and encrypting it, then increasing the value of the IV block by one to generate the next block of key stream material. When finished, XOR the key stream with the plaintext. Decrypt in the same manner.\n\n\n# ex3_13.py \n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os \n\nAES_BLOCK_SIZE_IN_BYTES = 16\nAES_BLOCK_SIZE_IN_BITS = 128\n\nclass MyOwnCTR:\n    def __init__(self, key: bytes, nonce: bytes): \n        assert(len(nonce) == AES_BLOCK_SIZE_IN_BYTES)\n        self.key = key \n        self.nonce = nonce \n\n    def encryptor(self): \n        return Encryptor(config=self) \n    \n    def decryptor(self): \n        # Note that in CTR, encryption and decryption are exactly the same operations. \n        return Encryptor(config=self)\n    \nclass Encryptor: \n    def __init__(self, config: MyOwnCTR):  \n        self.config = config \n        self.current_nonce = self.config.nonce\n        self._encryptor = Cipher(\n            algorithm=algorithms.AES(self.config.key), \n            mode=modes.ECB(), \n            backend=default_backend(),\n        ).encryptor()\n        self.e_current_nonce = self._encryptor.update(self.current_nonce)\n        self.buffer = b''\n\n    def update(self, plaintext: bytes) -&gt; bytes: \n        self.buffer += plaintext\n        retval = b\"\"  \n        while len(self.buffer) &gt; 0:\n            if len(self.e_current_nonce) == 0: \n                self.current_nonce = increment_the_nonce(nonce=self.current_nonce)\n                self.e_current_nonce = self._encryptor.update(self.current_nonce)\n            k = min(\n                len(self.buffer), \n                len(self.e_current_nonce),\n            )\n            retval += xor_two_byte_strings(\n                self.buffer[:k],\n                self.e_current_nonce[:k],\n            )\n            self.buffer = self.buffer[k:]\n            self.e_current_nonce = self.e_current_nonce[k:]\n        return retval\n    \n    def finalize(self): \n        assert(len(self.buffer) == 0)\n        return b\"\" \n\ndef increment_the_nonce(nonce: bytes) -&gt; bytes: \n    nonce = (int.from_bytes(nonce,'big') + 1)%(2**128)\n    return int.to_bytes(nonce, length=16, byteorder='big')\n\n# the following function is taken from Exercise 3.9. \ndef xor_two_byte_strings(x: bytes, y: bytes) -&gt; bytes: \n    assert(len(x) == len(y))\n    \n    result = []\n    for _1, _2 in zip(x, y): \n        result.append(_1 ^ _2)\n    return bytes(result)\n\nif __name__ == '__main__': \n    key = os.urandom(32) \n    nonce = os.urandom(16) \n\n    plaintext = b\"This is a very secret and long plaintext...\"\n\n    my_ctr = MyOwnCTR(key=key, nonce=nonce) \n    my_ctr_encryptor = my_ctr.encryptor()\n    my_ctr_decryptor = my_ctr.decryptor()\n\n    ciphertext1 = my_ctr_encryptor.update(plaintext)\n    print(my_ctr_decryptor.update(ciphertext1))\n\n    official_ctr = Cipher(\n        algorithm=algorithms.AES(key), \n        mode=modes.CTR(nonce),\n        backend=default_backend(),\n    )\n    official_ctr_encryptor = official_ctr.encryptor()\n    official_ctr_decryptor = official_ctr.decryptor()\n\n    ciphertext2 = official_ctr_encryptor.update(plaintext) \n    print(official_ctr_decryptor.update(ciphertext2))\n\n    print(f\"Passed: {ciphertext1 == ciphertext2}\")\nAnd that is how we create our own CTR mode from ECB mode.\nNote that in the above code we didn‚Äôt need padding of the plaintext.\nWhen we run the above code we get the following:"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.12.html",
    "href": "Ch3_Symmetric_Encryption/3.12.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.12: HAND-CRAFTED CBC\nECB mode is just raw AES. You can create your own CBC Mode using ECB as the building block (Never use this for production code! Always use well-tested libraries). For this exercise, see if you can build a CBC encryption and decryption operation that is compatible with the cryptography library. For encryption, remember to take the output of each block and XOR it with the plaintext of the next block before encryption. Reverse the process for decryption.\n\n\n# ex3_12.py \n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os \n\nclass MyOwnCBC:\n    def __init__(self, key: bytes, iv: bytes): \n        self.key = key \n        self.iv = iv \n\n    def encryptor(self): \n        return Encryptor(config=self) \n    \n    def decryptor(self): \n        return Decryptor(config=self)\n\nclass Encryptor: \n    def __init__(self, config: MyOwnCBC):  \n        self.config = config \n        self.buffer = b\"\"\n        self.previous_ciphertext = self.config.iv \n        self._encryptor = Cipher(\n            algorithm=algorithms.AES(self.config.key), \n            mode=modes.ECB(), \n            backend=default_backend(),\n        ).encryptor()\n\n    def update(self, plaintext: bytes) -&gt; bytes: \n        self.buffer += plaintext\n        retval = b\"\"  \n        while len(self.buffer) &gt;= 16:\n            single_block = self.buffer[:16]\n            self.buffer = self.buffer[16:]\n            pre_cipher_block = xor_two_byte_strings(single_block, self.previous_ciphertext)\n            self.previous_ciphertext = self._encryptor.update(pre_cipher_block) \n            retval += self.previous_ciphertext\n        return retval\n    \n    def finalize(self): \n        assert(len(self.buffer) == 0)\n        return b\"\"  \n\nclass Decryptor: \n    def __init__(self, config: MyOwnCBC):  \n        self.config = config \n        self.buffer = b\"\"\n        self.previous_ciphertext = self.config.iv \n        self._decryptor = Cipher(\n            algorithm=algorithms.AES(self.config.key), \n            mode=modes.ECB(), \n            backend=default_backend(),\n        ).decryptor()\n\n    def update(self, ciphertext: bytes) -&gt; bytes: \n        self.buffer += ciphertext\n        retval = b\"\"  \n        while len(self.buffer) &gt;= 16:\n            single_block = self.buffer[:16]\n            self.buffer = self.buffer[16:]\n            pre_plaintext_block = self._decryptor.update(single_block) \n            retval += xor_two_byte_strings(pre_plaintext_block, self.previous_ciphertext)\n            self.previous_ciphertext = single_block\n        return retval\n    \n    def finalize(self): \n        assert(len(self.buffer) == 0)\n        return b\"\"  \n\n\n# the following function is taken from Exercise 3.9. \ndef xor_two_byte_strings(x: bytes, y: bytes) -&gt; bytes: \n    assert(len(x) == len(y))\n    \n    result = []\n    for _1, _2 in zip(x, y): \n        result.append(_1 ^ _2)\n    return bytes(result)\n\nif __name__ == '__main__': \n    key = os.urandom(32) \n    iv = os.urandom(16) \n\n    plaintext = b\"This is a very secret and long plaintext...\"\n    # pad it up, so that the length of plaintext is a multiple of 16 bytes.\n    plaintext = plaintext + b\"\\x00\"*(16 - (len(plaintext)%16))\n\n    my_cbc = MyOwnCBC(key=key, iv=iv) \n    my_cbc_encryptor = my_cbc.encryptor()\n    my_cbc_decryptor = my_cbc.decryptor()\n\n    ciphertext1 = my_cbc_encryptor.update(plaintext)\n    print(my_cbc_decryptor.update(ciphertext=ciphertext1))\n\n    official_cbc = Cipher(\n        algorithm=algorithms.AES(key), \n        mode=modes.CBC(iv),\n        backend=default_backend(),\n    )\n    official_cbc_encryptor = official_cbc.encryptor()\n    official_cbc_decryptor = official_cbc.decryptor()\n\n    ciphertext2 = official_cbc_encryptor.update(plaintext) \n    print(official_cbc_decryptor.update(ciphertext2))\n\n    print(f\"Passed: {ciphertext1 == ciphertext2}\")\nSo, that is how you build your own AES-CBC!!\nRunning the above code, gives the following result:\n\nAlso, note that the plaintext is 3 blocks long."
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.20.html",
    "href": "Ch3_Symmetric_Encryption/3.20.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.20: STATISTICS ARE ALSO FUTILE\nInstrument your padding oracle attack in the previous exercise to calculate how many guesses it took to fully decrypt the entire message and calculate an average number of tries per byte. In theory, it should work out to about 256 tries per byte. But you‚Äôre probably working with such small numbers that it will vary widely. In our tests on a \\(96\\)-byte message, our averages varied between about \\(220\\) guesses per byte and \\(290\\) guesses per byte.\n\n\n# ex3_20.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import padding\nimport os\n\ndef sslv3Pad(msg): \n    padNeeded = (16 - (len(msg) % 16)) - 1\n    padding = padNeeded.to_bytes(padNeeded+1, \"big\")\n    return msg + padding \n\ndef sslv3Unpad(padded_msg): \n    paddingLen = padded_msg[-1] + 1 \n    return padded_msg[:-paddingLen]\n\nclass Oracle:\n    '''\n    The Oracle class basically models the SSLv3 Servers. \n    '''\n    def __init__(self, key, iv):\n        self.key = key\n        self.iv = iv\n\n    def accept(self, ciphertext) -&gt; bool:\n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        decryptor = aesCipher.decryptor()\n        plaintext = decryptor.update(ciphertext)\n        plaintext += decryptor.finalize()\n        return plaintext[-1] == 15\n\n    def update_key_and_iv(self, ciphertext) -&gt; bytes: \n        '''\n        Change the key & iv that ciphertext was created. \n        '''\n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        decryptor = aesCipher.decryptor()\n        plaintext = decryptor.update(ciphertext)\n        plaintext += decryptor.finalize()\n\n        self.key = os.urandom(16)\n        self.iv = os.urandom(16)\n\n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        encryptor = aesCipher.encryptor() \n        ciphertext = encryptor.update(plaintext)\n        ciphertext += encryptor.finalize()\n        return ciphertext  \n\n\n    def right_shift_plaintext(self,ciphertext: bytes) -&gt; bytes: \n        aesCipher = Cipher(algorithms.AES(self.key),\n                           modes.CBC(self.iv),\n                           backend=default_backend())\n        decryptor = aesCipher.decryptor()\n        plaintext = decryptor.update(ciphertext)\n        plaintext += decryptor.finalize()\n\n        plaintext = b\"-\" + plaintext[:-17] + plaintext[-16:]\n        \n        encryptor = aesCipher.encryptor() \n        _ciphertext = encryptor.update(plaintext) \n        _ciphertext += encryptor.finalize()\n        return _ciphertext \n    \n    @staticmethod\n    def start_experiment(): \n        msg = b\"msg is 16 bytesS\"\n        msg_padded = sslv3Pad(msg) \n\n        o = Oracle(key=os.urandom(16), iv=os.urandom(16))\n        aesCipher = Cipher(algorithms.AES(o.key),\n                           modes.CBC(o.iv),\n                           backend=default_backend())\n        encryptor = aesCipher.encryptor() \n        ciphertext = encryptor.update(msg_padded)\n        ciphertext += encryptor.finalize() \n        assert(o.accept(ciphertext=ciphertext))\n        return ciphertext, o \n        \n\n# This function assumes that the last cipher text block is a full\n# block of SSLV3 padding\ndef lucky_get_one_byte(iv, ciphertext, block_number, oracle):\n    block_start = block_number * 16\n    block_end = block_start + 16\n    block = ciphertext[block_start:block_end]\n\n    # Copy the block over the last block.\n    mod_ciphertext = ciphertext[:-16] + block\n    if not oracle.accept(mod_ciphertext):\n        return False, None\n\n    # This is valid! Let's get the byte!\n    # We first need the byte decrypted from the block.\n    # It was XORed with second to last block, so\n    # byte = 15 XOR (last byte of second-to-last block).\n    second_to_last = ciphertext[-32:-16]\n    intermediate = second_to_last[-1]^15\n\n    # We still have to XOR it with its *real*\n    # preceding block in order to get the true value.\n    if block_number == 0:\n        prev_block = iv\n    else:\n        prev_block = ciphertext[block_start-16:block_start]\n\n    return True, intermediate ^ prev_block[-1]\n    \nif __name__ == '__main__': \n    ciphertext, o = Oracle.start_experiment() \n    plaintext_recovered = []\n    # let's suppose the attacker knows that the plaintext is 16 characters/bytes long. \n    length_of_plaintext_length = 16 \n    number_of_guesses = 0 \n    while length_of_plaintext_length &gt; 0:\n        number_of_guesses += 1  \n        status, byte = lucky_get_one_byte(iv=o.iv, ciphertext=ciphertext, block_number=0, oracle=o) \n        if (status): \n            plaintext_recovered.append(byte)\n            ciphertext = o.right_shift_plaintext(ciphertext=ciphertext)\n            length_of_plaintext_length -= 1\n        else: \n            ciphertext = o.update_key_and_iv(ciphertext=ciphertext)\n        \n\n    plaintext_recovered.reverse()\n    print(\"Plaintext recovered: \", bytes(plaintext_recovered).decode())\n    print(f\"Number of Guesses to fully decrypt the message: {number_of_guesses}\")\n    print(f\"Average number of tries per byte: {number_of_guesses/16}\") # since there are 16 bytes in plaintext\nRunning the above code gives us the following:"
  },
  {
    "objectID": "Ch3_Symmetric_Encryption/3.11.html",
    "href": "Ch3_Symmetric_Encryption/3.11.html",
    "title": ".",
    "section": "",
    "text": "EXERCISE 3.11: ENCRYPTING AN IMAGE\nEncrypt the image that you encrypted with ECB mode earlier. What does the encrypted image look like now? Don‚Äôt forget to leave the first 54 bytes untouched!\n\n\nI created the following bmp file using GIMP:\n\nThen I wrote the following code to encrypt the above bmp file in both ECB and CBC mode.\n# ex3_11.py\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os \n\nifile = \"top-secret.bmp\"\n\nkey = os.urandom(16) # we are using AES-128 \niv = os.urandom(16) \n\n# first encrypt using ECB \ndef encryptUsingECB(): \n    ofile = \"top-secret-ecb.bmp\"\n    with open(ifile, \"rb\") as reader: \n        with open(ofile, \"wb\") as writer: \n            image_data = reader.read() \n            header, body = image_data[:54], image_data[54:]\n            \n            # now encrypt the body\n            encryptor = Cipher(\n                algorithm=algorithms.AES(key),\n                mode=modes.ECB(),\n                backend=default_backend()\n            ).encryptor()\n\n            # padding the body. \n            body += b\"\\x00\"*(16 - (len(body)%16))\n\n            writer.write(header + encryptor.update(body))\n\n\n# then encrypt using CBC \ndef encryptUsingCBC(): \n    ofile = \"top-secret-cbc.bmp\"\n    with open(ifile, \"rb\") as reader: \n        with open(ofile, \"wb\") as writer: \n            image_data = reader.read() \n            header, body = image_data[:54], image_data[54:]\n            \n            # now encrypt the body\n            encryptor = Cipher(\n                algorithm=algorithms.AES(key),\n                mode=modes.CBC(iv),\n                backend=default_backend()\n            ).encryptor()\n\n            # padding the body. \n            body += b\"\\x00\"*(16 - (len(body)%16))\n\n            writer.write(header + encryptor.update(body))\n\nif __name__ == '__main__': \n    encryptUsingECB()\n    encryptUsingCBC()\nRunning the above code will generate two files as shown below:\n\nThe following shows the encrypted versions of the above bmp file:"
  }
]